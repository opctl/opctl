// Code generated by counterfeiter. DO NOT EDIT.
package cliparamsatisfier

import (
	"sync"

	"github.com/opctl/opctl/sdks/go/types"
)

type Fake struct {
	NewCliPromptInputSrcStub        func(inputs map[string]*types.Param) InputSrc
	newCliPromptInputSrcMutex       sync.RWMutex
	newCliPromptInputSrcArgsForCall []struct {
		inputs map[string]*types.Param
	}
	newCliPromptInputSrcReturns struct {
		result1 InputSrc
	}
	newCliPromptInputSrcReturnsOnCall map[int]struct {
		result1 InputSrc
	}
	NewEnvVarInputSrcStub        func() InputSrc
	newEnvVarInputSrcMutex       sync.RWMutex
	newEnvVarInputSrcArgsForCall []struct{}
	newEnvVarInputSrcReturns     struct {
		result1 InputSrc
	}
	newEnvVarInputSrcReturnsOnCall map[int]struct {
		result1 InputSrc
	}
	NewParamDefaultInputSrcStub        func(inputs map[string]*types.Param) InputSrc
	newParamDefaultInputSrcMutex       sync.RWMutex
	newParamDefaultInputSrcArgsForCall []struct {
		inputs map[string]*types.Param
	}
	newParamDefaultInputSrcReturns struct {
		result1 InputSrc
	}
	newParamDefaultInputSrcReturnsOnCall map[int]struct {
		result1 InputSrc
	}
	NewSliceInputSrcStub        func(args []string, sep string) InputSrc
	newSliceInputSrcMutex       sync.RWMutex
	newSliceInputSrcArgsForCall []struct {
		args []string
		sep  string
	}
	newSliceInputSrcReturns struct {
		result1 InputSrc
	}
	newSliceInputSrcReturnsOnCall map[int]struct {
		result1 InputSrc
	}
	NewYMLFileInputSrcStub        func(filePath string) (InputSrc, error)
	newYMLFileInputSrcMutex       sync.RWMutex
	newYMLFileInputSrcArgsForCall []struct {
		filePath string
	}
	newYMLFileInputSrcReturns struct {
		result1 InputSrc
		result2 error
	}
	newYMLFileInputSrcReturnsOnCall map[int]struct {
		result1 InputSrc
		result2 error
	}
	SatisfyStub        func(inputSourcer InputSourcer, inputs map[string]*types.Param) map[string]*types.Value
	satisfyMutex       sync.RWMutex
	satisfyArgsForCall []struct {
		inputSourcer InputSourcer
		inputs       map[string]*types.Param
	}
	satisfyReturns struct {
		result1 map[string]*types.Value
	}
	satisfyReturnsOnCall map[int]struct {
		result1 map[string]*types.Value
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Fake) NewCliPromptInputSrc(inputs map[string]*types.Param) InputSrc {
	fake.newCliPromptInputSrcMutex.Lock()
	ret, specificReturn := fake.newCliPromptInputSrcReturnsOnCall[len(fake.newCliPromptInputSrcArgsForCall)]
	fake.newCliPromptInputSrcArgsForCall = append(fake.newCliPromptInputSrcArgsForCall, struct {
		inputs map[string]*types.Param
	}{inputs})
	fake.recordInvocation("NewCliPromptInputSrc", []interface{}{inputs})
	fake.newCliPromptInputSrcMutex.Unlock()
	if fake.NewCliPromptInputSrcStub != nil {
		return fake.NewCliPromptInputSrcStub(inputs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newCliPromptInputSrcReturns.result1
}

func (fake *Fake) NewCliPromptInputSrcCallCount() int {
	fake.newCliPromptInputSrcMutex.RLock()
	defer fake.newCliPromptInputSrcMutex.RUnlock()
	return len(fake.newCliPromptInputSrcArgsForCall)
}

func (fake *Fake) NewCliPromptInputSrcArgsForCall(i int) map[string]*types.Param {
	fake.newCliPromptInputSrcMutex.RLock()
	defer fake.newCliPromptInputSrcMutex.RUnlock()
	return fake.newCliPromptInputSrcArgsForCall[i].inputs
}

func (fake *Fake) NewCliPromptInputSrcReturns(result1 InputSrc) {
	fake.NewCliPromptInputSrcStub = nil
	fake.newCliPromptInputSrcReturns = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewCliPromptInputSrcReturnsOnCall(i int, result1 InputSrc) {
	fake.NewCliPromptInputSrcStub = nil
	if fake.newCliPromptInputSrcReturnsOnCall == nil {
		fake.newCliPromptInputSrcReturnsOnCall = make(map[int]struct {
			result1 InputSrc
		})
	}
	fake.newCliPromptInputSrcReturnsOnCall[i] = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewEnvVarInputSrc() InputSrc {
	fake.newEnvVarInputSrcMutex.Lock()
	ret, specificReturn := fake.newEnvVarInputSrcReturnsOnCall[len(fake.newEnvVarInputSrcArgsForCall)]
	fake.newEnvVarInputSrcArgsForCall = append(fake.newEnvVarInputSrcArgsForCall, struct{}{})
	fake.recordInvocation("NewEnvVarInputSrc", []interface{}{})
	fake.newEnvVarInputSrcMutex.Unlock()
	if fake.NewEnvVarInputSrcStub != nil {
		return fake.NewEnvVarInputSrcStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newEnvVarInputSrcReturns.result1
}

func (fake *Fake) NewEnvVarInputSrcCallCount() int {
	fake.newEnvVarInputSrcMutex.RLock()
	defer fake.newEnvVarInputSrcMutex.RUnlock()
	return len(fake.newEnvVarInputSrcArgsForCall)
}

func (fake *Fake) NewEnvVarInputSrcReturns(result1 InputSrc) {
	fake.NewEnvVarInputSrcStub = nil
	fake.newEnvVarInputSrcReturns = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewEnvVarInputSrcReturnsOnCall(i int, result1 InputSrc) {
	fake.NewEnvVarInputSrcStub = nil
	if fake.newEnvVarInputSrcReturnsOnCall == nil {
		fake.newEnvVarInputSrcReturnsOnCall = make(map[int]struct {
			result1 InputSrc
		})
	}
	fake.newEnvVarInputSrcReturnsOnCall[i] = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewParamDefaultInputSrc(inputs map[string]*types.Param) InputSrc {
	fake.newParamDefaultInputSrcMutex.Lock()
	ret, specificReturn := fake.newParamDefaultInputSrcReturnsOnCall[len(fake.newParamDefaultInputSrcArgsForCall)]
	fake.newParamDefaultInputSrcArgsForCall = append(fake.newParamDefaultInputSrcArgsForCall, struct {
		inputs map[string]*types.Param
	}{inputs})
	fake.recordInvocation("NewParamDefaultInputSrc", []interface{}{inputs})
	fake.newParamDefaultInputSrcMutex.Unlock()
	if fake.NewParamDefaultInputSrcStub != nil {
		return fake.NewParamDefaultInputSrcStub(inputs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newParamDefaultInputSrcReturns.result1
}

func (fake *Fake) NewParamDefaultInputSrcCallCount() int {
	fake.newParamDefaultInputSrcMutex.RLock()
	defer fake.newParamDefaultInputSrcMutex.RUnlock()
	return len(fake.newParamDefaultInputSrcArgsForCall)
}

func (fake *Fake) NewParamDefaultInputSrcArgsForCall(i int) map[string]*types.Param {
	fake.newParamDefaultInputSrcMutex.RLock()
	defer fake.newParamDefaultInputSrcMutex.RUnlock()
	return fake.newParamDefaultInputSrcArgsForCall[i].inputs
}

func (fake *Fake) NewParamDefaultInputSrcReturns(result1 InputSrc) {
	fake.NewParamDefaultInputSrcStub = nil
	fake.newParamDefaultInputSrcReturns = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewParamDefaultInputSrcReturnsOnCall(i int, result1 InputSrc) {
	fake.NewParamDefaultInputSrcStub = nil
	if fake.newParamDefaultInputSrcReturnsOnCall == nil {
		fake.newParamDefaultInputSrcReturnsOnCall = make(map[int]struct {
			result1 InputSrc
		})
	}
	fake.newParamDefaultInputSrcReturnsOnCall[i] = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewSliceInputSrc(args []string, sep string) InputSrc {
	var argsCopy []string
	if args != nil {
		argsCopy = make([]string, len(args))
		copy(argsCopy, args)
	}
	fake.newSliceInputSrcMutex.Lock()
	ret, specificReturn := fake.newSliceInputSrcReturnsOnCall[len(fake.newSliceInputSrcArgsForCall)]
	fake.newSliceInputSrcArgsForCall = append(fake.newSliceInputSrcArgsForCall, struct {
		args []string
		sep  string
	}{argsCopy, sep})
	fake.recordInvocation("NewSliceInputSrc", []interface{}{argsCopy, sep})
	fake.newSliceInputSrcMutex.Unlock()
	if fake.NewSliceInputSrcStub != nil {
		return fake.NewSliceInputSrcStub(args, sep)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newSliceInputSrcReturns.result1
}

func (fake *Fake) NewSliceInputSrcCallCount() int {
	fake.newSliceInputSrcMutex.RLock()
	defer fake.newSliceInputSrcMutex.RUnlock()
	return len(fake.newSliceInputSrcArgsForCall)
}

func (fake *Fake) NewSliceInputSrcArgsForCall(i int) ([]string, string) {
	fake.newSliceInputSrcMutex.RLock()
	defer fake.newSliceInputSrcMutex.RUnlock()
	return fake.newSliceInputSrcArgsForCall[i].args, fake.newSliceInputSrcArgsForCall[i].sep
}

func (fake *Fake) NewSliceInputSrcReturns(result1 InputSrc) {
	fake.NewSliceInputSrcStub = nil
	fake.newSliceInputSrcReturns = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewSliceInputSrcReturnsOnCall(i int, result1 InputSrc) {
	fake.NewSliceInputSrcStub = nil
	if fake.newSliceInputSrcReturnsOnCall == nil {
		fake.newSliceInputSrcReturnsOnCall = make(map[int]struct {
			result1 InputSrc
		})
	}
	fake.newSliceInputSrcReturnsOnCall[i] = struct {
		result1 InputSrc
	}{result1}
}

func (fake *Fake) NewYMLFileInputSrc(filePath string) (InputSrc, error) {
	fake.newYMLFileInputSrcMutex.Lock()
	ret, specificReturn := fake.newYMLFileInputSrcReturnsOnCall[len(fake.newYMLFileInputSrcArgsForCall)]
	fake.newYMLFileInputSrcArgsForCall = append(fake.newYMLFileInputSrcArgsForCall, struct {
		filePath string
	}{filePath})
	fake.recordInvocation("NewYMLFileInputSrc", []interface{}{filePath})
	fake.newYMLFileInputSrcMutex.Unlock()
	if fake.NewYMLFileInputSrcStub != nil {
		return fake.NewYMLFileInputSrcStub(filePath)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.newYMLFileInputSrcReturns.result1, fake.newYMLFileInputSrcReturns.result2
}

func (fake *Fake) NewYMLFileInputSrcCallCount() int {
	fake.newYMLFileInputSrcMutex.RLock()
	defer fake.newYMLFileInputSrcMutex.RUnlock()
	return len(fake.newYMLFileInputSrcArgsForCall)
}

func (fake *Fake) NewYMLFileInputSrcArgsForCall(i int) string {
	fake.newYMLFileInputSrcMutex.RLock()
	defer fake.newYMLFileInputSrcMutex.RUnlock()
	return fake.newYMLFileInputSrcArgsForCall[i].filePath
}

func (fake *Fake) NewYMLFileInputSrcReturns(result1 InputSrc, result2 error) {
	fake.NewYMLFileInputSrcStub = nil
	fake.newYMLFileInputSrcReturns = struct {
		result1 InputSrc
		result2 error
	}{result1, result2}
}

func (fake *Fake) NewYMLFileInputSrcReturnsOnCall(i int, result1 InputSrc, result2 error) {
	fake.NewYMLFileInputSrcStub = nil
	if fake.newYMLFileInputSrcReturnsOnCall == nil {
		fake.newYMLFileInputSrcReturnsOnCall = make(map[int]struct {
			result1 InputSrc
			result2 error
		})
	}
	fake.newYMLFileInputSrcReturnsOnCall[i] = struct {
		result1 InputSrc
		result2 error
	}{result1, result2}
}

func (fake *Fake) Satisfy(inputSourcer InputSourcer, inputs map[string]*types.Param) map[string]*types.Value {
	fake.satisfyMutex.Lock()
	ret, specificReturn := fake.satisfyReturnsOnCall[len(fake.satisfyArgsForCall)]
	fake.satisfyArgsForCall = append(fake.satisfyArgsForCall, struct {
		inputSourcer InputSourcer
		inputs       map[string]*types.Param
	}{inputSourcer, inputs})
	fake.recordInvocation("Satisfy", []interface{}{inputSourcer, inputs})
	fake.satisfyMutex.Unlock()
	if fake.SatisfyStub != nil {
		return fake.SatisfyStub(inputSourcer, inputs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.satisfyReturns.result1
}

func (fake *Fake) SatisfyCallCount() int {
	fake.satisfyMutex.RLock()
	defer fake.satisfyMutex.RUnlock()
	return len(fake.satisfyArgsForCall)
}

func (fake *Fake) SatisfyArgsForCall(i int) (InputSourcer, map[string]*types.Param) {
	fake.satisfyMutex.RLock()
	defer fake.satisfyMutex.RUnlock()
	return fake.satisfyArgsForCall[i].inputSourcer, fake.satisfyArgsForCall[i].inputs
}

func (fake *Fake) SatisfyReturns(result1 map[string]*types.Value) {
	fake.SatisfyStub = nil
	fake.satisfyReturns = struct {
		result1 map[string]*types.Value
	}{result1}
}

func (fake *Fake) SatisfyReturnsOnCall(i int, result1 map[string]*types.Value) {
	fake.SatisfyStub = nil
	if fake.satisfyReturnsOnCall == nil {
		fake.satisfyReturnsOnCall = make(map[int]struct {
			result1 map[string]*types.Value
		})
	}
	fake.satisfyReturnsOnCall[i] = struct {
		result1 map[string]*types.Value
	}{result1}
}

func (fake *Fake) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newCliPromptInputSrcMutex.RLock()
	defer fake.newCliPromptInputSrcMutex.RUnlock()
	fake.newEnvVarInputSrcMutex.RLock()
	defer fake.newEnvVarInputSrcMutex.RUnlock()
	fake.newParamDefaultInputSrcMutex.RLock()
	defer fake.newParamDefaultInputSrcMutex.RUnlock()
	fake.newSliceInputSrcMutex.RLock()
	defer fake.newSliceInputSrcMutex.RUnlock()
	fake.newYMLFileInputSrcMutex.RLock()
	defer fake.newYMLFileInputSrcMutex.RUnlock()
	fake.satisfyMutex.RLock()
	defer fake.satisfyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Fake) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ CLIParamSatisfier = new(Fake)
