// Code generated by counterfeiter. DO NOT EDIT.
package docker

import (
	"context"
	"io"
	"net"
	"net/http"
	"sync"
	"time"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/events"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/image"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/api/types/registry"
	"github.com/docker/docker/api/types/swarm"
	"github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/client"
)

type fakeDockerClient struct {
	BuildCachePruneStub        func(context.Context, types.BuildCachePruneOptions) (*types.BuildCachePruneReport, error)
	buildCachePruneMutex       sync.RWMutex
	buildCachePruneArgsForCall []struct {
		arg1 context.Context
		arg2 types.BuildCachePruneOptions
	}
	buildCachePruneReturns struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}
	buildCachePruneReturnsOnCall map[int]struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}
	BuildCancelStub        func(context.Context, string) error
	buildCancelMutex       sync.RWMutex
	buildCancelArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	buildCancelReturns struct {
		result1 error
	}
	buildCancelReturnsOnCall map[int]struct {
		result1 error
	}
	ClientVersionStub        func() string
	clientVersionMutex       sync.RWMutex
	clientVersionArgsForCall []struct {
	}
	clientVersionReturns struct {
		result1 string
	}
	clientVersionReturnsOnCall map[int]struct {
		result1 string
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigCreateStub        func(context.Context, swarm.ConfigSpec) (types.ConfigCreateResponse, error)
	configCreateMutex       sync.RWMutex
	configCreateArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.ConfigSpec
	}
	configCreateReturns struct {
		result1 types.ConfigCreateResponse
		result2 error
	}
	configCreateReturnsOnCall map[int]struct {
		result1 types.ConfigCreateResponse
		result2 error
	}
	ConfigInspectWithRawStub        func(context.Context, string) (swarm.Config, []byte, error)
	configInspectWithRawMutex       sync.RWMutex
	configInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	configInspectWithRawReturns struct {
		result1 swarm.Config
		result2 []byte
		result3 error
	}
	configInspectWithRawReturnsOnCall map[int]struct {
		result1 swarm.Config
		result2 []byte
		result3 error
	}
	ConfigListStub        func(context.Context, types.ConfigListOptions) ([]swarm.Config, error)
	configListMutex       sync.RWMutex
	configListArgsForCall []struct {
		arg1 context.Context
		arg2 types.ConfigListOptions
	}
	configListReturns struct {
		result1 []swarm.Config
		result2 error
	}
	configListReturnsOnCall map[int]struct {
		result1 []swarm.Config
		result2 error
	}
	ConfigRemoveStub        func(context.Context, string) error
	configRemoveMutex       sync.RWMutex
	configRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	configRemoveReturns struct {
		result1 error
	}
	configRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ConfigUpdateStub        func(context.Context, string, swarm.Version, swarm.ConfigSpec) error
	configUpdateMutex       sync.RWMutex
	configUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.ConfigSpec
	}
	configUpdateReturns struct {
		result1 error
	}
	configUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerAttachStub        func(context.Context, string, types.ContainerAttachOptions) (types.HijackedResponse, error)
	containerAttachMutex       sync.RWMutex
	containerAttachArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerAttachOptions
	}
	containerAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerCommitStub        func(context.Context, string, types.ContainerCommitOptions) (types.IDResponse, error)
	containerCommitMutex       sync.RWMutex
	containerCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerCommitOptions
	}
	containerCommitReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerCommitReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerCreateStub        func(context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, string) (container.ContainerCreateCreatedBody, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		arg1 context.Context
		arg2 *container.Config
		arg3 *container.HostConfig
		arg4 *network.NetworkingConfig
		arg5 string
	}
	containerCreateReturns struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	ContainerDiffStub        func(context.Context, string) ([]container.ContainerChangeResponseItem, error)
	containerDiffMutex       sync.RWMutex
	containerDiffArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerDiffReturns struct {
		result1 []container.ContainerChangeResponseItem
		result2 error
	}
	containerDiffReturnsOnCall map[int]struct {
		result1 []container.ContainerChangeResponseItem
		result2 error
	}
	ContainerExecAttachStub        func(context.Context, string, types.ExecStartCheck) (types.HijackedResponse, error)
	containerExecAttachMutex       sync.RWMutex
	containerExecAttachArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ExecStartCheck
	}
	containerExecAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerExecAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerExecCreateStub        func(context.Context, string, types.ExecConfig) (types.IDResponse, error)
	containerExecCreateMutex       sync.RWMutex
	containerExecCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ExecConfig
	}
	containerExecCreateReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerExecCreateReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerExecInspectStub        func(context.Context, string) (types.ContainerExecInspect, error)
	containerExecInspectMutex       sync.RWMutex
	containerExecInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerExecInspectReturns struct {
		result1 types.ContainerExecInspect
		result2 error
	}
	containerExecInspectReturnsOnCall map[int]struct {
		result1 types.ContainerExecInspect
		result2 error
	}
	ContainerExecResizeStub        func(context.Context, string, types.ResizeOptions) error
	containerExecResizeMutex       sync.RWMutex
	containerExecResizeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ResizeOptions
	}
	containerExecResizeReturns struct {
		result1 error
	}
	containerExecResizeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerExecStartStub        func(context.Context, string, types.ExecStartCheck) error
	containerExecStartMutex       sync.RWMutex
	containerExecStartArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ExecStartCheck
	}
	containerExecStartReturns struct {
		result1 error
	}
	containerExecStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerExportStub        func(context.Context, string) (io.ReadCloser, error)
	containerExportMutex       sync.RWMutex
	containerExportArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerExportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerExportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerInspectStub        func(context.Context, string) (types.ContainerJSON, error)
	containerInspectMutex       sync.RWMutex
	containerInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerInspectReturns struct {
		result1 types.ContainerJSON
		result2 error
	}
	containerInspectReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 error
	}
	ContainerInspectWithRawStub        func(context.Context, string, bool) (types.ContainerJSON, []byte, error)
	containerInspectWithRawMutex       sync.RWMutex
	containerInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}
	containerInspectWithRawReturns struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}
	containerInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}
	ContainerKillStub        func(context.Context, string, string) error
	containerKillMutex       sync.RWMutex
	containerKillArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	containerKillReturns struct {
		result1 error
	}
	containerKillReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerListStub        func(context.Context, types.ContainerListOptions) ([]types.Container, error)
	containerListMutex       sync.RWMutex
	containerListArgsForCall []struct {
		arg1 context.Context
		arg2 types.ContainerListOptions
	}
	containerListReturns struct {
		result1 []types.Container
		result2 error
	}
	containerListReturnsOnCall map[int]struct {
		result1 []types.Container
		result2 error
	}
	ContainerLogsStub        func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerPauseStub        func(context.Context, string) error
	containerPauseMutex       sync.RWMutex
	containerPauseArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerPauseReturns struct {
		result1 error
	}
	containerPauseReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRemoveStub        func(context.Context, string, types.ContainerRemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerRemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	containerRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRenameStub        func(context.Context, string, string) error
	containerRenameMutex       sync.RWMutex
	containerRenameArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	containerRenameReturns struct {
		result1 error
	}
	containerRenameReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerResizeStub        func(context.Context, string, types.ResizeOptions) error
	containerResizeMutex       sync.RWMutex
	containerResizeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ResizeOptions
	}
	containerResizeReturns struct {
		result1 error
	}
	containerResizeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRestartStub        func(context.Context, string, *time.Duration) error
	containerRestartMutex       sync.RWMutex
	containerRestartArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *time.Duration
	}
	containerRestartReturns struct {
		result1 error
	}
	containerRestartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStartStub        func(context.Context, string, types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStatPathStub        func(context.Context, string, string) (types.ContainerPathStat, error)
	containerStatPathMutex       sync.RWMutex
	containerStatPathArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	containerStatPathReturns struct {
		result1 types.ContainerPathStat
		result2 error
	}
	containerStatPathReturnsOnCall map[int]struct {
		result1 types.ContainerPathStat
		result2 error
	}
	ContainerStatsStub        func(context.Context, string, bool) (types.ContainerStats, error)
	containerStatsMutex       sync.RWMutex
	containerStatsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}
	containerStatsReturns struct {
		result1 types.ContainerStats
		result2 error
	}
	containerStatsReturnsOnCall map[int]struct {
		result1 types.ContainerStats
		result2 error
	}
	ContainerStopStub        func(context.Context, string, *time.Duration) error
	containerStopMutex       sync.RWMutex
	containerStopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *time.Duration
	}
	containerStopReturns struct {
		result1 error
	}
	containerStopReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerTopStub        func(context.Context, string, []string) (container.ContainerTopOKBody, error)
	containerTopMutex       sync.RWMutex
	containerTopArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	containerTopReturns struct {
		result1 container.ContainerTopOKBody
		result2 error
	}
	containerTopReturnsOnCall map[int]struct {
		result1 container.ContainerTopOKBody
		result2 error
	}
	ContainerUnpauseStub        func(context.Context, string) error
	containerUnpauseMutex       sync.RWMutex
	containerUnpauseArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	containerUnpauseReturns struct {
		result1 error
	}
	containerUnpauseReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerUpdateStub        func(context.Context, string, container.UpdateConfig) (container.ContainerUpdateOKBody, error)
	containerUpdateMutex       sync.RWMutex
	containerUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.UpdateConfig
	}
	containerUpdateReturns struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}
	containerUpdateReturnsOnCall map[int]struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}
	ContainerWaitStub        func(context.Context, string, container.WaitCondition) (<-chan container.ContainerWaitOKBody, <-chan error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 container.WaitCondition
	}
	containerWaitReturns struct {
		result1 <-chan container.ContainerWaitOKBody
		result2 <-chan error
	}
	containerWaitReturnsOnCall map[int]struct {
		result1 <-chan container.ContainerWaitOKBody
		result2 <-chan error
	}
	ContainersPruneStub        func(context.Context, filters.Args) (types.ContainersPruneReport, error)
	containersPruneMutex       sync.RWMutex
	containersPruneArgsForCall []struct {
		arg1 context.Context
		arg2 filters.Args
	}
	containersPruneReturns struct {
		result1 types.ContainersPruneReport
		result2 error
	}
	containersPruneReturnsOnCall map[int]struct {
		result1 types.ContainersPruneReport
		result2 error
	}
	CopyFromContainerStub        func(context.Context, string, string) (io.ReadCloser, types.ContainerPathStat, error)
	copyFromContainerMutex       sync.RWMutex
	copyFromContainerArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	copyFromContainerReturns struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}
	copyFromContainerReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}
	CopyToContainerStub        func(context.Context, string, string, io.Reader, types.CopyToContainerOptions) error
	copyToContainerMutex       sync.RWMutex
	copyToContainerArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 io.Reader
		arg5 types.CopyToContainerOptions
	}
	copyToContainerReturns struct {
		result1 error
	}
	copyToContainerReturnsOnCall map[int]struct {
		result1 error
	}
	DaemonHostStub        func() string
	daemonHostMutex       sync.RWMutex
	daemonHostArgsForCall []struct {
	}
	daemonHostReturns struct {
		result1 string
	}
	daemonHostReturnsOnCall map[int]struct {
		result1 string
	}
	DialSessionStub        func(context.Context, string, map[string][]string) (net.Conn, error)
	dialSessionMutex       sync.RWMutex
	dialSessionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string][]string
	}
	dialSessionReturns struct {
		result1 net.Conn
		result2 error
	}
	dialSessionReturnsOnCall map[int]struct {
		result1 net.Conn
		result2 error
	}
	DialerStub        func() func(context.Context) (net.Conn, error)
	dialerMutex       sync.RWMutex
	dialerArgsForCall []struct {
	}
	dialerReturns struct {
		result1 func(context.Context) (net.Conn, error)
	}
	dialerReturnsOnCall map[int]struct {
		result1 func(context.Context) (net.Conn, error)
	}
	DiskUsageStub        func(context.Context) (types.DiskUsage, error)
	diskUsageMutex       sync.RWMutex
	diskUsageArgsForCall []struct {
		arg1 context.Context
	}
	diskUsageReturns struct {
		result1 types.DiskUsage
		result2 error
	}
	diskUsageReturnsOnCall map[int]struct {
		result1 types.DiskUsage
		result2 error
	}
	DistributionInspectStub        func(context.Context, string, string) (registry.DistributionInspect, error)
	distributionInspectMutex       sync.RWMutex
	distributionInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	distributionInspectReturns struct {
		result1 registry.DistributionInspect
		result2 error
	}
	distributionInspectReturnsOnCall map[int]struct {
		result1 registry.DistributionInspect
		result2 error
	}
	EventsStub        func(context.Context, types.EventsOptions) (<-chan events.Message, <-chan error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 context.Context
		arg2 types.EventsOptions
	}
	eventsReturns struct {
		result1 <-chan events.Message
		result2 <-chan error
	}
	eventsReturnsOnCall map[int]struct {
		result1 <-chan events.Message
		result2 <-chan error
	}
	HTTPClientStub        func() *http.Client
	hTTPClientMutex       sync.RWMutex
	hTTPClientArgsForCall []struct {
	}
	hTTPClientReturns struct {
		result1 *http.Client
	}
	hTTPClientReturnsOnCall map[int]struct {
		result1 *http.Client
	}
	ImageBuildStub        func(context.Context, io.Reader, types.ImageBuildOptions) (types.ImageBuildResponse, error)
	imageBuildMutex       sync.RWMutex
	imageBuildArgsForCall []struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 types.ImageBuildOptions
	}
	imageBuildReturns struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	imageBuildReturnsOnCall map[int]struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	ImageCreateStub        func(context.Context, string, types.ImageCreateOptions) (io.ReadCloser, error)
	imageCreateMutex       sync.RWMutex
	imageCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImageCreateOptions
	}
	imageCreateReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageCreateReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageHistoryStub        func(context.Context, string) ([]image.HistoryResponseItem, error)
	imageHistoryMutex       sync.RWMutex
	imageHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	imageHistoryReturns struct {
		result1 []image.HistoryResponseItem
		result2 error
	}
	imageHistoryReturnsOnCall map[int]struct {
		result1 []image.HistoryResponseItem
		result2 error
	}
	ImageImportStub        func(context.Context, types.ImageImportSource, string, types.ImageImportOptions) (io.ReadCloser, error)
	imageImportMutex       sync.RWMutex
	imageImportArgsForCall []struct {
		arg1 context.Context
		arg2 types.ImageImportSource
		arg3 string
		arg4 types.ImageImportOptions
	}
	imageImportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageImportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageInspectWithRawStub        func(context.Context, string) (types.ImageInspect, []byte, error)
	imageInspectWithRawMutex       sync.RWMutex
	imageInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	imageInspectWithRawReturns struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	imageInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	ImageListStub        func(context.Context, types.ImageListOptions) ([]types.ImageSummary, error)
	imageListMutex       sync.RWMutex
	imageListArgsForCall []struct {
		arg1 context.Context
		arg2 types.ImageListOptions
	}
	imageListReturns struct {
		result1 []types.ImageSummary
		result2 error
	}
	imageListReturnsOnCall map[int]struct {
		result1 []types.ImageSummary
		result2 error
	}
	ImageLoadStub        func(context.Context, io.Reader, bool) (types.ImageLoadResponse, error)
	imageLoadMutex       sync.RWMutex
	imageLoadArgsForCall []struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 bool
	}
	imageLoadReturns struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	imageLoadReturnsOnCall map[int]struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	ImagePullStub        func(context.Context, string, types.ImagePullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImagePullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePullReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImagePushStub        func(context.Context, string, types.ImagePushOptions) (io.ReadCloser, error)
	imagePushMutex       sync.RWMutex
	imagePushArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImagePushOptions
	}
	imagePushReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePushReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageRemoveStub        func(context.Context, string, types.ImageRemoveOptions) ([]types.ImageDeleteResponseItem, error)
	imageRemoveMutex       sync.RWMutex
	imageRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImageRemoveOptions
	}
	imageRemoveReturns struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}
	imageRemoveReturnsOnCall map[int]struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}
	ImageSaveStub        func(context.Context, []string) (io.ReadCloser, error)
	imageSaveMutex       sync.RWMutex
	imageSaveArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	imageSaveReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageSaveReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageSearchStub        func(context.Context, string, types.ImageSearchOptions) ([]registry.SearchResult, error)
	imageSearchMutex       sync.RWMutex
	imageSearchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImageSearchOptions
	}
	imageSearchReturns struct {
		result1 []registry.SearchResult
		result2 error
	}
	imageSearchReturnsOnCall map[int]struct {
		result1 []registry.SearchResult
		result2 error
	}
	ImageTagStub        func(context.Context, string, string) error
	imageTagMutex       sync.RWMutex
	imageTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	imageTagReturns struct {
		result1 error
	}
	imageTagReturnsOnCall map[int]struct {
		result1 error
	}
	ImagesPruneStub        func(context.Context, filters.Args) (types.ImagesPruneReport, error)
	imagesPruneMutex       sync.RWMutex
	imagesPruneArgsForCall []struct {
		arg1 context.Context
		arg2 filters.Args
	}
	imagesPruneReturns struct {
		result1 types.ImagesPruneReport
		result2 error
	}
	imagesPruneReturnsOnCall map[int]struct {
		result1 types.ImagesPruneReport
		result2 error
	}
	InfoStub        func(context.Context) (types.Info, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 context.Context
	}
	infoReturns struct {
		result1 types.Info
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 types.Info
		result2 error
	}
	NegotiateAPIVersionStub        func(context.Context)
	negotiateAPIVersionMutex       sync.RWMutex
	negotiateAPIVersionArgsForCall []struct {
		arg1 context.Context
	}
	NegotiateAPIVersionPingStub        func(types.Ping)
	negotiateAPIVersionPingMutex       sync.RWMutex
	negotiateAPIVersionPingArgsForCall []struct {
		arg1 types.Ping
	}
	NetworkConnectStub        func(context.Context, string, string, *network.EndpointSettings) error
	networkConnectMutex       sync.RWMutex
	networkConnectArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *network.EndpointSettings
	}
	networkConnectReturns struct {
		result1 error
	}
	networkConnectReturnsOnCall map[int]struct {
		result1 error
	}
	NetworkCreateStub        func(context.Context, string, types.NetworkCreate) (types.NetworkCreateResponse, error)
	networkCreateMutex       sync.RWMutex
	networkCreateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.NetworkCreate
	}
	networkCreateReturns struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	networkCreateReturnsOnCall map[int]struct {
		result1 types.NetworkCreateResponse
		result2 error
	}
	NetworkDisconnectStub        func(context.Context, string, string, bool) error
	networkDisconnectMutex       sync.RWMutex
	networkDisconnectArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 bool
	}
	networkDisconnectReturns struct {
		result1 error
	}
	networkDisconnectReturnsOnCall map[int]struct {
		result1 error
	}
	NetworkInspectStub        func(context.Context, string, types.NetworkInspectOptions) (types.NetworkResource, error)
	networkInspectMutex       sync.RWMutex
	networkInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.NetworkInspectOptions
	}
	networkInspectReturns struct {
		result1 types.NetworkResource
		result2 error
	}
	networkInspectReturnsOnCall map[int]struct {
		result1 types.NetworkResource
		result2 error
	}
	NetworkInspectWithRawStub        func(context.Context, string, types.NetworkInspectOptions) (types.NetworkResource, []byte, error)
	networkInspectWithRawMutex       sync.RWMutex
	networkInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.NetworkInspectOptions
	}
	networkInspectWithRawReturns struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}
	networkInspectWithRawReturnsOnCall map[int]struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}
	NetworkListStub        func(context.Context, types.NetworkListOptions) ([]types.NetworkResource, error)
	networkListMutex       sync.RWMutex
	networkListArgsForCall []struct {
		arg1 context.Context
		arg2 types.NetworkListOptions
	}
	networkListReturns struct {
		result1 []types.NetworkResource
		result2 error
	}
	networkListReturnsOnCall map[int]struct {
		result1 []types.NetworkResource
		result2 error
	}
	NetworkRemoveStub        func(context.Context, string) error
	networkRemoveMutex       sync.RWMutex
	networkRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	networkRemoveReturns struct {
		result1 error
	}
	networkRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	NetworksPruneStub        func(context.Context, filters.Args) (types.NetworksPruneReport, error)
	networksPruneMutex       sync.RWMutex
	networksPruneArgsForCall []struct {
		arg1 context.Context
		arg2 filters.Args
	}
	networksPruneReturns struct {
		result1 types.NetworksPruneReport
		result2 error
	}
	networksPruneReturnsOnCall map[int]struct {
		result1 types.NetworksPruneReport
		result2 error
	}
	NodeInspectWithRawStub        func(context.Context, string) (swarm.Node, []byte, error)
	nodeInspectWithRawMutex       sync.RWMutex
	nodeInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	nodeInspectWithRawReturns struct {
		result1 swarm.Node
		result2 []byte
		result3 error
	}
	nodeInspectWithRawReturnsOnCall map[int]struct {
		result1 swarm.Node
		result2 []byte
		result3 error
	}
	NodeListStub        func(context.Context, types.NodeListOptions) ([]swarm.Node, error)
	nodeListMutex       sync.RWMutex
	nodeListArgsForCall []struct {
		arg1 context.Context
		arg2 types.NodeListOptions
	}
	nodeListReturns struct {
		result1 []swarm.Node
		result2 error
	}
	nodeListReturnsOnCall map[int]struct {
		result1 []swarm.Node
		result2 error
	}
	NodeRemoveStub        func(context.Context, string, types.NodeRemoveOptions) error
	nodeRemoveMutex       sync.RWMutex
	nodeRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.NodeRemoveOptions
	}
	nodeRemoveReturns struct {
		result1 error
	}
	nodeRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	NodeUpdateStub        func(context.Context, string, swarm.Version, swarm.NodeSpec) error
	nodeUpdateMutex       sync.RWMutex
	nodeUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.NodeSpec
	}
	nodeUpdateReturns struct {
		result1 error
	}
	nodeUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	PingStub        func(context.Context) (types.Ping, error)
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 context.Context
	}
	pingReturns struct {
		result1 types.Ping
		result2 error
	}
	pingReturnsOnCall map[int]struct {
		result1 types.Ping
		result2 error
	}
	PluginCreateStub        func(context.Context, io.Reader, types.PluginCreateOptions) error
	pluginCreateMutex       sync.RWMutex
	pluginCreateArgsForCall []struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 types.PluginCreateOptions
	}
	pluginCreateReturns struct {
		result1 error
	}
	pluginCreateReturnsOnCall map[int]struct {
		result1 error
	}
	PluginDisableStub        func(context.Context, string, types.PluginDisableOptions) error
	pluginDisableMutex       sync.RWMutex
	pluginDisableArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginDisableOptions
	}
	pluginDisableReturns struct {
		result1 error
	}
	pluginDisableReturnsOnCall map[int]struct {
		result1 error
	}
	PluginEnableStub        func(context.Context, string, types.PluginEnableOptions) error
	pluginEnableMutex       sync.RWMutex
	pluginEnableArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginEnableOptions
	}
	pluginEnableReturns struct {
		result1 error
	}
	pluginEnableReturnsOnCall map[int]struct {
		result1 error
	}
	PluginInspectWithRawStub        func(context.Context, string) (*types.Plugin, []byte, error)
	pluginInspectWithRawMutex       sync.RWMutex
	pluginInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	pluginInspectWithRawReturns struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}
	pluginInspectWithRawReturnsOnCall map[int]struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}
	PluginInstallStub        func(context.Context, string, types.PluginInstallOptions) (io.ReadCloser, error)
	pluginInstallMutex       sync.RWMutex
	pluginInstallArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginInstallOptions
	}
	pluginInstallReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	pluginInstallReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	PluginListStub        func(context.Context, filters.Args) (types.PluginsListResponse, error)
	pluginListMutex       sync.RWMutex
	pluginListArgsForCall []struct {
		arg1 context.Context
		arg2 filters.Args
	}
	pluginListReturns struct {
		result1 types.PluginsListResponse
		result2 error
	}
	pluginListReturnsOnCall map[int]struct {
		result1 types.PluginsListResponse
		result2 error
	}
	PluginPushStub        func(context.Context, string, string) (io.ReadCloser, error)
	pluginPushMutex       sync.RWMutex
	pluginPushArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	pluginPushReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	pluginPushReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	PluginRemoveStub        func(context.Context, string, types.PluginRemoveOptions) error
	pluginRemoveMutex       sync.RWMutex
	pluginRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginRemoveOptions
	}
	pluginRemoveReturns struct {
		result1 error
	}
	pluginRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	PluginSetStub        func(context.Context, string, []string) error
	pluginSetMutex       sync.RWMutex
	pluginSetArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	pluginSetReturns struct {
		result1 error
	}
	pluginSetReturnsOnCall map[int]struct {
		result1 error
	}
	PluginUpgradeStub        func(context.Context, string, types.PluginInstallOptions) (io.ReadCloser, error)
	pluginUpgradeMutex       sync.RWMutex
	pluginUpgradeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginInstallOptions
	}
	pluginUpgradeReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	pluginUpgradeReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	RegistryLoginStub        func(context.Context, types.AuthConfig) (registry.AuthenticateOKBody, error)
	registryLoginMutex       sync.RWMutex
	registryLoginArgsForCall []struct {
		arg1 context.Context
		arg2 types.AuthConfig
	}
	registryLoginReturns struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}
	registryLoginReturnsOnCall map[int]struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}
	SecretCreateStub        func(context.Context, swarm.SecretSpec) (types.SecretCreateResponse, error)
	secretCreateMutex       sync.RWMutex
	secretCreateArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.SecretSpec
	}
	secretCreateReturns struct {
		result1 types.SecretCreateResponse
		result2 error
	}
	secretCreateReturnsOnCall map[int]struct {
		result1 types.SecretCreateResponse
		result2 error
	}
	SecretInspectWithRawStub        func(context.Context, string) (swarm.Secret, []byte, error)
	secretInspectWithRawMutex       sync.RWMutex
	secretInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	secretInspectWithRawReturns struct {
		result1 swarm.Secret
		result2 []byte
		result3 error
	}
	secretInspectWithRawReturnsOnCall map[int]struct {
		result1 swarm.Secret
		result2 []byte
		result3 error
	}
	SecretListStub        func(context.Context, types.SecretListOptions) ([]swarm.Secret, error)
	secretListMutex       sync.RWMutex
	secretListArgsForCall []struct {
		arg1 context.Context
		arg2 types.SecretListOptions
	}
	secretListReturns struct {
		result1 []swarm.Secret
		result2 error
	}
	secretListReturnsOnCall map[int]struct {
		result1 []swarm.Secret
		result2 error
	}
	SecretRemoveStub        func(context.Context, string) error
	secretRemoveMutex       sync.RWMutex
	secretRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	secretRemoveReturns struct {
		result1 error
	}
	secretRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	SecretUpdateStub        func(context.Context, string, swarm.Version, swarm.SecretSpec) error
	secretUpdateMutex       sync.RWMutex
	secretUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.SecretSpec
	}
	secretUpdateReturns struct {
		result1 error
	}
	secretUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	ServerVersionStub        func(context.Context) (types.Version, error)
	serverVersionMutex       sync.RWMutex
	serverVersionArgsForCall []struct {
		arg1 context.Context
	}
	serverVersionReturns struct {
		result1 types.Version
		result2 error
	}
	serverVersionReturnsOnCall map[int]struct {
		result1 types.Version
		result2 error
	}
	ServiceCreateStub        func(context.Context, swarm.ServiceSpec, types.ServiceCreateOptions) (types.ServiceCreateResponse, error)
	serviceCreateMutex       sync.RWMutex
	serviceCreateArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.ServiceSpec
		arg3 types.ServiceCreateOptions
	}
	serviceCreateReturns struct {
		result1 types.ServiceCreateResponse
		result2 error
	}
	serviceCreateReturnsOnCall map[int]struct {
		result1 types.ServiceCreateResponse
		result2 error
	}
	ServiceInspectWithRawStub        func(context.Context, string, types.ServiceInspectOptions) (swarm.Service, []byte, error)
	serviceInspectWithRawMutex       sync.RWMutex
	serviceInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ServiceInspectOptions
	}
	serviceInspectWithRawReturns struct {
		result1 swarm.Service
		result2 []byte
		result3 error
	}
	serviceInspectWithRawReturnsOnCall map[int]struct {
		result1 swarm.Service
		result2 []byte
		result3 error
	}
	ServiceListStub        func(context.Context, types.ServiceListOptions) ([]swarm.Service, error)
	serviceListMutex       sync.RWMutex
	serviceListArgsForCall []struct {
		arg1 context.Context
		arg2 types.ServiceListOptions
	}
	serviceListReturns struct {
		result1 []swarm.Service
		result2 error
	}
	serviceListReturnsOnCall map[int]struct {
		result1 []swarm.Service
		result2 error
	}
	ServiceLogsStub        func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)
	serviceLogsMutex       sync.RWMutex
	serviceLogsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}
	serviceLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	serviceLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ServiceRemoveStub        func(context.Context, string) error
	serviceRemoveMutex       sync.RWMutex
	serviceRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	serviceRemoveReturns struct {
		result1 error
	}
	serviceRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ServiceUpdateStub        func(context.Context, string, swarm.Version, swarm.ServiceSpec, types.ServiceUpdateOptions) (types.ServiceUpdateResponse, error)
	serviceUpdateMutex       sync.RWMutex
	serviceUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.ServiceSpec
		arg5 types.ServiceUpdateOptions
	}
	serviceUpdateReturns struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}
	serviceUpdateReturnsOnCall map[int]struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}
	SwarmGetUnlockKeyStub        func(context.Context) (types.SwarmUnlockKeyResponse, error)
	swarmGetUnlockKeyMutex       sync.RWMutex
	swarmGetUnlockKeyArgsForCall []struct {
		arg1 context.Context
	}
	swarmGetUnlockKeyReturns struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}
	swarmGetUnlockKeyReturnsOnCall map[int]struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}
	SwarmInitStub        func(context.Context, swarm.InitRequest) (string, error)
	swarmInitMutex       sync.RWMutex
	swarmInitArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.InitRequest
	}
	swarmInitReturns struct {
		result1 string
		result2 error
	}
	swarmInitReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SwarmInspectStub        func(context.Context) (swarm.Swarm, error)
	swarmInspectMutex       sync.RWMutex
	swarmInspectArgsForCall []struct {
		arg1 context.Context
	}
	swarmInspectReturns struct {
		result1 swarm.Swarm
		result2 error
	}
	swarmInspectReturnsOnCall map[int]struct {
		result1 swarm.Swarm
		result2 error
	}
	SwarmJoinStub        func(context.Context, swarm.JoinRequest) error
	swarmJoinMutex       sync.RWMutex
	swarmJoinArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.JoinRequest
	}
	swarmJoinReturns struct {
		result1 error
	}
	swarmJoinReturnsOnCall map[int]struct {
		result1 error
	}
	SwarmLeaveStub        func(context.Context, bool) error
	swarmLeaveMutex       sync.RWMutex
	swarmLeaveArgsForCall []struct {
		arg1 context.Context
		arg2 bool
	}
	swarmLeaveReturns struct {
		result1 error
	}
	swarmLeaveReturnsOnCall map[int]struct {
		result1 error
	}
	SwarmUnlockStub        func(context.Context, swarm.UnlockRequest) error
	swarmUnlockMutex       sync.RWMutex
	swarmUnlockArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.UnlockRequest
	}
	swarmUnlockReturns struct {
		result1 error
	}
	swarmUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	SwarmUpdateStub        func(context.Context, swarm.Version, swarm.Spec, swarm.UpdateFlags) error
	swarmUpdateMutex       sync.RWMutex
	swarmUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 swarm.Version
		arg3 swarm.Spec
		arg4 swarm.UpdateFlags
	}
	swarmUpdateReturns struct {
		result1 error
	}
	swarmUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	TaskInspectWithRawStub        func(context.Context, string) (swarm.Task, []byte, error)
	taskInspectWithRawMutex       sync.RWMutex
	taskInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	taskInspectWithRawReturns struct {
		result1 swarm.Task
		result2 []byte
		result3 error
	}
	taskInspectWithRawReturnsOnCall map[int]struct {
		result1 swarm.Task
		result2 []byte
		result3 error
	}
	TaskListStub        func(context.Context, types.TaskListOptions) ([]swarm.Task, error)
	taskListMutex       sync.RWMutex
	taskListArgsForCall []struct {
		arg1 context.Context
		arg2 types.TaskListOptions
	}
	taskListReturns struct {
		result1 []swarm.Task
		result2 error
	}
	taskListReturnsOnCall map[int]struct {
		result1 []swarm.Task
		result2 error
	}
	TaskLogsStub        func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)
	taskLogsMutex       sync.RWMutex
	taskLogsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}
	taskLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	taskLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	VolumeCreateStub        func(context.Context, volume.VolumeCreateBody) (types.Volume, error)
	volumeCreateMutex       sync.RWMutex
	volumeCreateArgsForCall []struct {
		arg1 context.Context
		arg2 volume.VolumeCreateBody
	}
	volumeCreateReturns struct {
		result1 types.Volume
		result2 error
	}
	volumeCreateReturnsOnCall map[int]struct {
		result1 types.Volume
		result2 error
	}
	VolumeInspectStub        func(context.Context, string) (types.Volume, error)
	volumeInspectMutex       sync.RWMutex
	volumeInspectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	volumeInspectReturns struct {
		result1 types.Volume
		result2 error
	}
	volumeInspectReturnsOnCall map[int]struct {
		result1 types.Volume
		result2 error
	}
	VolumeInspectWithRawStub        func(context.Context, string) (types.Volume, []byte, error)
	volumeInspectWithRawMutex       sync.RWMutex
	volumeInspectWithRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	volumeInspectWithRawReturns struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}
	volumeInspectWithRawReturnsOnCall map[int]struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}
	VolumeListStub        func(context.Context, filters.Args) (volume.VolumeListOKBody, error)
	volumeListMutex       sync.RWMutex
	volumeListArgsForCall []struct {
		arg1 context.Context
		arg2 filters.Args
	}
	volumeListReturns struct {
		result1 volume.VolumeListOKBody
		result2 error
	}
	volumeListReturnsOnCall map[int]struct {
		result1 volume.VolumeListOKBody
		result2 error
	}
	VolumeRemoveStub        func(context.Context, string, bool) error
	volumeRemoveMutex       sync.RWMutex
	volumeRemoveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}
	volumeRemoveReturns struct {
		result1 error
	}
	volumeRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	VolumesPruneStub        func(context.Context, filters.Args) (types.VolumesPruneReport, error)
	volumesPruneMutex       sync.RWMutex
	volumesPruneArgsForCall []struct {
		arg1 context.Context
		arg2 filters.Args
	}
	volumesPruneReturns struct {
		result1 types.VolumesPruneReport
		result2 error
	}
	volumesPruneReturnsOnCall map[int]struct {
		result1 types.VolumesPruneReport
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *fakeDockerClient) BuildCachePrune(arg1 context.Context, arg2 types.BuildCachePruneOptions) (*types.BuildCachePruneReport, error) {
	fake.buildCachePruneMutex.Lock()
	ret, specificReturn := fake.buildCachePruneReturnsOnCall[len(fake.buildCachePruneArgsForCall)]
	fake.buildCachePruneArgsForCall = append(fake.buildCachePruneArgsForCall, struct {
		arg1 context.Context
		arg2 types.BuildCachePruneOptions
	}{arg1, arg2})
	fake.recordInvocation("BuildCachePrune", []interface{}{arg1, arg2})
	fake.buildCachePruneMutex.Unlock()
	if fake.BuildCachePruneStub != nil {
		return fake.BuildCachePruneStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.buildCachePruneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) BuildCachePruneCallCount() int {
	fake.buildCachePruneMutex.RLock()
	defer fake.buildCachePruneMutex.RUnlock()
	return len(fake.buildCachePruneArgsForCall)
}

func (fake *fakeDockerClient) BuildCachePruneCalls(stub func(context.Context, types.BuildCachePruneOptions) (*types.BuildCachePruneReport, error)) {
	fake.buildCachePruneMutex.Lock()
	defer fake.buildCachePruneMutex.Unlock()
	fake.BuildCachePruneStub = stub
}

func (fake *fakeDockerClient) BuildCachePruneArgsForCall(i int) (context.Context, types.BuildCachePruneOptions) {
	fake.buildCachePruneMutex.RLock()
	defer fake.buildCachePruneMutex.RUnlock()
	argsForCall := fake.buildCachePruneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) BuildCachePruneReturns(result1 *types.BuildCachePruneReport, result2 error) {
	fake.buildCachePruneMutex.Lock()
	defer fake.buildCachePruneMutex.Unlock()
	fake.BuildCachePruneStub = nil
	fake.buildCachePruneReturns = struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) BuildCachePruneReturnsOnCall(i int, result1 *types.BuildCachePruneReport, result2 error) {
	fake.buildCachePruneMutex.Lock()
	defer fake.buildCachePruneMutex.Unlock()
	fake.BuildCachePruneStub = nil
	if fake.buildCachePruneReturnsOnCall == nil {
		fake.buildCachePruneReturnsOnCall = make(map[int]struct {
			result1 *types.BuildCachePruneReport
			result2 error
		})
	}
	fake.buildCachePruneReturnsOnCall[i] = struct {
		result1 *types.BuildCachePruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) BuildCancel(arg1 context.Context, arg2 string) error {
	fake.buildCancelMutex.Lock()
	ret, specificReturn := fake.buildCancelReturnsOnCall[len(fake.buildCancelArgsForCall)]
	fake.buildCancelArgsForCall = append(fake.buildCancelArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("BuildCancel", []interface{}{arg1, arg2})
	fake.buildCancelMutex.Unlock()
	if fake.BuildCancelStub != nil {
		return fake.BuildCancelStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.buildCancelReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) BuildCancelCallCount() int {
	fake.buildCancelMutex.RLock()
	defer fake.buildCancelMutex.RUnlock()
	return len(fake.buildCancelArgsForCall)
}

func (fake *fakeDockerClient) BuildCancelCalls(stub func(context.Context, string) error) {
	fake.buildCancelMutex.Lock()
	defer fake.buildCancelMutex.Unlock()
	fake.BuildCancelStub = stub
}

func (fake *fakeDockerClient) BuildCancelArgsForCall(i int) (context.Context, string) {
	fake.buildCancelMutex.RLock()
	defer fake.buildCancelMutex.RUnlock()
	argsForCall := fake.buildCancelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) BuildCancelReturns(result1 error) {
	fake.buildCancelMutex.Lock()
	defer fake.buildCancelMutex.Unlock()
	fake.BuildCancelStub = nil
	fake.buildCancelReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) BuildCancelReturnsOnCall(i int, result1 error) {
	fake.buildCancelMutex.Lock()
	defer fake.buildCancelMutex.Unlock()
	fake.BuildCancelStub = nil
	if fake.buildCancelReturnsOnCall == nil {
		fake.buildCancelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.buildCancelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ClientVersion() string {
	fake.clientVersionMutex.Lock()
	ret, specificReturn := fake.clientVersionReturnsOnCall[len(fake.clientVersionArgsForCall)]
	fake.clientVersionArgsForCall = append(fake.clientVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("ClientVersion", []interface{}{})
	fake.clientVersionMutex.Unlock()
	if fake.ClientVersionStub != nil {
		return fake.ClientVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.clientVersionReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ClientVersionCallCount() int {
	fake.clientVersionMutex.RLock()
	defer fake.clientVersionMutex.RUnlock()
	return len(fake.clientVersionArgsForCall)
}

func (fake *fakeDockerClient) ClientVersionCalls(stub func() string) {
	fake.clientVersionMutex.Lock()
	defer fake.clientVersionMutex.Unlock()
	fake.ClientVersionStub = stub
}

func (fake *fakeDockerClient) ClientVersionReturns(result1 string) {
	fake.clientVersionMutex.Lock()
	defer fake.clientVersionMutex.Unlock()
	fake.ClientVersionStub = nil
	fake.clientVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) ClientVersionReturnsOnCall(i int, result1 string) {
	fake.clientVersionMutex.Lock()
	defer fake.clientVersionMutex.Unlock()
	fake.ClientVersionStub = nil
	if fake.clientVersionReturnsOnCall == nil {
		fake.clientVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.clientVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.closeReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *fakeDockerClient) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *fakeDockerClient) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigCreate(arg1 context.Context, arg2 swarm.ConfigSpec) (types.ConfigCreateResponse, error) {
	fake.configCreateMutex.Lock()
	ret, specificReturn := fake.configCreateReturnsOnCall[len(fake.configCreateArgsForCall)]
	fake.configCreateArgsForCall = append(fake.configCreateArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.ConfigSpec
	}{arg1, arg2})
	fake.recordInvocation("ConfigCreate", []interface{}{arg1, arg2})
	fake.configCreateMutex.Unlock()
	if fake.ConfigCreateStub != nil {
		return fake.ConfigCreateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.configCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ConfigCreateCallCount() int {
	fake.configCreateMutex.RLock()
	defer fake.configCreateMutex.RUnlock()
	return len(fake.configCreateArgsForCall)
}

func (fake *fakeDockerClient) ConfigCreateCalls(stub func(context.Context, swarm.ConfigSpec) (types.ConfigCreateResponse, error)) {
	fake.configCreateMutex.Lock()
	defer fake.configCreateMutex.Unlock()
	fake.ConfigCreateStub = stub
}

func (fake *fakeDockerClient) ConfigCreateArgsForCall(i int) (context.Context, swarm.ConfigSpec) {
	fake.configCreateMutex.RLock()
	defer fake.configCreateMutex.RUnlock()
	argsForCall := fake.configCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ConfigCreateReturns(result1 types.ConfigCreateResponse, result2 error) {
	fake.configCreateMutex.Lock()
	defer fake.configCreateMutex.Unlock()
	fake.ConfigCreateStub = nil
	fake.configCreateReturns = struct {
		result1 types.ConfigCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigCreateReturnsOnCall(i int, result1 types.ConfigCreateResponse, result2 error) {
	fake.configCreateMutex.Lock()
	defer fake.configCreateMutex.Unlock()
	fake.ConfigCreateStub = nil
	if fake.configCreateReturnsOnCall == nil {
		fake.configCreateReturnsOnCall = make(map[int]struct {
			result1 types.ConfigCreateResponse
			result2 error
		})
	}
	fake.configCreateReturnsOnCall[i] = struct {
		result1 types.ConfigCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigInspectWithRaw(arg1 context.Context, arg2 string) (swarm.Config, []byte, error) {
	fake.configInspectWithRawMutex.Lock()
	ret, specificReturn := fake.configInspectWithRawReturnsOnCall[len(fake.configInspectWithRawArgsForCall)]
	fake.configInspectWithRawArgsForCall = append(fake.configInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ConfigInspectWithRaw", []interface{}{arg1, arg2})
	fake.configInspectWithRawMutex.Unlock()
	if fake.ConfigInspectWithRawStub != nil {
		return fake.ConfigInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.configInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) ConfigInspectWithRawCallCount() int {
	fake.configInspectWithRawMutex.RLock()
	defer fake.configInspectWithRawMutex.RUnlock()
	return len(fake.configInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ConfigInspectWithRawCalls(stub func(context.Context, string) (swarm.Config, []byte, error)) {
	fake.configInspectWithRawMutex.Lock()
	defer fake.configInspectWithRawMutex.Unlock()
	fake.ConfigInspectWithRawStub = stub
}

func (fake *fakeDockerClient) ConfigInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.configInspectWithRawMutex.RLock()
	defer fake.configInspectWithRawMutex.RUnlock()
	argsForCall := fake.configInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ConfigInspectWithRawReturns(result1 swarm.Config, result2 []byte, result3 error) {
	fake.configInspectWithRawMutex.Lock()
	defer fake.configInspectWithRawMutex.Unlock()
	fake.ConfigInspectWithRawStub = nil
	fake.configInspectWithRawReturns = struct {
		result1 swarm.Config
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ConfigInspectWithRawReturnsOnCall(i int, result1 swarm.Config, result2 []byte, result3 error) {
	fake.configInspectWithRawMutex.Lock()
	defer fake.configInspectWithRawMutex.Unlock()
	fake.ConfigInspectWithRawStub = nil
	if fake.configInspectWithRawReturnsOnCall == nil {
		fake.configInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarm.Config
			result2 []byte
			result3 error
		})
	}
	fake.configInspectWithRawReturnsOnCall[i] = struct {
		result1 swarm.Config
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ConfigList(arg1 context.Context, arg2 types.ConfigListOptions) ([]swarm.Config, error) {
	fake.configListMutex.Lock()
	ret, specificReturn := fake.configListReturnsOnCall[len(fake.configListArgsForCall)]
	fake.configListArgsForCall = append(fake.configListArgsForCall, struct {
		arg1 context.Context
		arg2 types.ConfigListOptions
	}{arg1, arg2})
	fake.recordInvocation("ConfigList", []interface{}{arg1, arg2})
	fake.configListMutex.Unlock()
	if fake.ConfigListStub != nil {
		return fake.ConfigListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.configListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ConfigListCallCount() int {
	fake.configListMutex.RLock()
	defer fake.configListMutex.RUnlock()
	return len(fake.configListArgsForCall)
}

func (fake *fakeDockerClient) ConfigListCalls(stub func(context.Context, types.ConfigListOptions) ([]swarm.Config, error)) {
	fake.configListMutex.Lock()
	defer fake.configListMutex.Unlock()
	fake.ConfigListStub = stub
}

func (fake *fakeDockerClient) ConfigListArgsForCall(i int) (context.Context, types.ConfigListOptions) {
	fake.configListMutex.RLock()
	defer fake.configListMutex.RUnlock()
	argsForCall := fake.configListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ConfigListReturns(result1 []swarm.Config, result2 error) {
	fake.configListMutex.Lock()
	defer fake.configListMutex.Unlock()
	fake.ConfigListStub = nil
	fake.configListReturns = struct {
		result1 []swarm.Config
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigListReturnsOnCall(i int, result1 []swarm.Config, result2 error) {
	fake.configListMutex.Lock()
	defer fake.configListMutex.Unlock()
	fake.ConfigListStub = nil
	if fake.configListReturnsOnCall == nil {
		fake.configListReturnsOnCall = make(map[int]struct {
			result1 []swarm.Config
			result2 error
		})
	}
	fake.configListReturnsOnCall[i] = struct {
		result1 []swarm.Config
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ConfigRemove(arg1 context.Context, arg2 string) error {
	fake.configRemoveMutex.Lock()
	ret, specificReturn := fake.configRemoveReturnsOnCall[len(fake.configRemoveArgsForCall)]
	fake.configRemoveArgsForCall = append(fake.configRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ConfigRemove", []interface{}{arg1, arg2})
	fake.configRemoveMutex.Unlock()
	if fake.ConfigRemoveStub != nil {
		return fake.ConfigRemoveStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ConfigRemoveCallCount() int {
	fake.configRemoveMutex.RLock()
	defer fake.configRemoveMutex.RUnlock()
	return len(fake.configRemoveArgsForCall)
}

func (fake *fakeDockerClient) ConfigRemoveCalls(stub func(context.Context, string) error) {
	fake.configRemoveMutex.Lock()
	defer fake.configRemoveMutex.Unlock()
	fake.ConfigRemoveStub = stub
}

func (fake *fakeDockerClient) ConfigRemoveArgsForCall(i int) (context.Context, string) {
	fake.configRemoveMutex.RLock()
	defer fake.configRemoveMutex.RUnlock()
	argsForCall := fake.configRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ConfigRemoveReturns(result1 error) {
	fake.configRemoveMutex.Lock()
	defer fake.configRemoveMutex.Unlock()
	fake.ConfigRemoveStub = nil
	fake.configRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigRemoveReturnsOnCall(i int, result1 error) {
	fake.configRemoveMutex.Lock()
	defer fake.configRemoveMutex.Unlock()
	fake.ConfigRemoveStub = nil
	if fake.configRemoveReturnsOnCall == nil {
		fake.configRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigUpdate(arg1 context.Context, arg2 string, arg3 swarm.Version, arg4 swarm.ConfigSpec) error {
	fake.configUpdateMutex.Lock()
	ret, specificReturn := fake.configUpdateReturnsOnCall[len(fake.configUpdateArgsForCall)]
	fake.configUpdateArgsForCall = append(fake.configUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.ConfigSpec
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ConfigUpdate", []interface{}{arg1, arg2, arg3, arg4})
	fake.configUpdateMutex.Unlock()
	if fake.ConfigUpdateStub != nil {
		return fake.ConfigUpdateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configUpdateReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ConfigUpdateCallCount() int {
	fake.configUpdateMutex.RLock()
	defer fake.configUpdateMutex.RUnlock()
	return len(fake.configUpdateArgsForCall)
}

func (fake *fakeDockerClient) ConfigUpdateCalls(stub func(context.Context, string, swarm.Version, swarm.ConfigSpec) error) {
	fake.configUpdateMutex.Lock()
	defer fake.configUpdateMutex.Unlock()
	fake.ConfigUpdateStub = stub
}

func (fake *fakeDockerClient) ConfigUpdateArgsForCall(i int) (context.Context, string, swarm.Version, swarm.ConfigSpec) {
	fake.configUpdateMutex.RLock()
	defer fake.configUpdateMutex.RUnlock()
	argsForCall := fake.configUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) ConfigUpdateReturns(result1 error) {
	fake.configUpdateMutex.Lock()
	defer fake.configUpdateMutex.Unlock()
	fake.ConfigUpdateStub = nil
	fake.configUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ConfigUpdateReturnsOnCall(i int, result1 error) {
	fake.configUpdateMutex.Lock()
	defer fake.configUpdateMutex.Unlock()
	fake.ConfigUpdateStub = nil
	if fake.configUpdateReturnsOnCall == nil {
		fake.configUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.configUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerAttach(arg1 context.Context, arg2 string, arg3 types.ContainerAttachOptions) (types.HijackedResponse, error) {
	fake.containerAttachMutex.Lock()
	ret, specificReturn := fake.containerAttachReturnsOnCall[len(fake.containerAttachArgsForCall)]
	fake.containerAttachArgsForCall = append(fake.containerAttachArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerAttachOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerAttach", []interface{}{arg1, arg2, arg3})
	fake.containerAttachMutex.Unlock()
	if fake.ContainerAttachStub != nil {
		return fake.ContainerAttachStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerAttachReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerAttachCallCount() int {
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	return len(fake.containerAttachArgsForCall)
}

func (fake *fakeDockerClient) ContainerAttachCalls(stub func(context.Context, string, types.ContainerAttachOptions) (types.HijackedResponse, error)) {
	fake.containerAttachMutex.Lock()
	defer fake.containerAttachMutex.Unlock()
	fake.ContainerAttachStub = stub
}

func (fake *fakeDockerClient) ContainerAttachArgsForCall(i int) (context.Context, string, types.ContainerAttachOptions) {
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	argsForCall := fake.containerAttachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.containerAttachMutex.Lock()
	defer fake.containerAttachMutex.Unlock()
	fake.ContainerAttachStub = nil
	fake.containerAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.containerAttachMutex.Lock()
	defer fake.containerAttachMutex.Unlock()
	fake.ContainerAttachStub = nil
	if fake.containerAttachReturnsOnCall == nil {
		fake.containerAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCommit(arg1 context.Context, arg2 string, arg3 types.ContainerCommitOptions) (types.IDResponse, error) {
	fake.containerCommitMutex.Lock()
	ret, specificReturn := fake.containerCommitReturnsOnCall[len(fake.containerCommitArgsForCall)]
	fake.containerCommitArgsForCall = append(fake.containerCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerCommitOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerCommit", []interface{}{arg1, arg2, arg3})
	fake.containerCommitMutex.Unlock()
	if fake.ContainerCommitStub != nil {
		return fake.ContainerCommitStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerCommitReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerCommitCallCount() int {
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	return len(fake.containerCommitArgsForCall)
}

func (fake *fakeDockerClient) ContainerCommitCalls(stub func(context.Context, string, types.ContainerCommitOptions) (types.IDResponse, error)) {
	fake.containerCommitMutex.Lock()
	defer fake.containerCommitMutex.Unlock()
	fake.ContainerCommitStub = stub
}

func (fake *fakeDockerClient) ContainerCommitArgsForCall(i int) (context.Context, string, types.ContainerCommitOptions) {
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	argsForCall := fake.containerCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerCommitReturns(result1 types.IDResponse, result2 error) {
	fake.containerCommitMutex.Lock()
	defer fake.containerCommitMutex.Unlock()
	fake.ContainerCommitStub = nil
	fake.containerCommitReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCommitReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.containerCommitMutex.Lock()
	defer fake.containerCommitMutex.Unlock()
	fake.ContainerCommitStub = nil
	if fake.containerCommitReturnsOnCall == nil {
		fake.containerCommitReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerCommitReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCreate(arg1 context.Context, arg2 *container.Config, arg3 *container.HostConfig, arg4 *network.NetworkingConfig, arg5 string) (container.ContainerCreateCreatedBody, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		arg1 context.Context
		arg2 *container.Config
		arg3 *container.HostConfig
		arg4 *network.NetworkingConfig
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ContainerCreate", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.containerCreateMutex.Unlock()
	if fake.ContainerCreateStub != nil {
		return fake.ContainerCreateStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerCreateCalls(stub func(context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, string) (container.ContainerCreateCreatedBody, error)) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = stub
}

func (fake *fakeDockerClient) ContainerCreateArgsForCall(i int) (context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	argsForCall := fake.containerCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *fakeDockerClient) ContainerCreateReturns(result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerCreateReturnsOnCall(i int, result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.containerCreateMutex.Lock()
	defer fake.containerCreateMutex.Unlock()
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 container.ContainerCreateCreatedBody
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerDiff(arg1 context.Context, arg2 string) ([]container.ContainerChangeResponseItem, error) {
	fake.containerDiffMutex.Lock()
	ret, specificReturn := fake.containerDiffReturnsOnCall[len(fake.containerDiffArgsForCall)]
	fake.containerDiffArgsForCall = append(fake.containerDiffArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ContainerDiff", []interface{}{arg1, arg2})
	fake.containerDiffMutex.Unlock()
	if fake.ContainerDiffStub != nil {
		return fake.ContainerDiffStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerDiffReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerDiffCallCount() int {
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	return len(fake.containerDiffArgsForCall)
}

func (fake *fakeDockerClient) ContainerDiffCalls(stub func(context.Context, string) ([]container.ContainerChangeResponseItem, error)) {
	fake.containerDiffMutex.Lock()
	defer fake.containerDiffMutex.Unlock()
	fake.ContainerDiffStub = stub
}

func (fake *fakeDockerClient) ContainerDiffArgsForCall(i int) (context.Context, string) {
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	argsForCall := fake.containerDiffArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerDiffReturns(result1 []container.ContainerChangeResponseItem, result2 error) {
	fake.containerDiffMutex.Lock()
	defer fake.containerDiffMutex.Unlock()
	fake.ContainerDiffStub = nil
	fake.containerDiffReturns = struct {
		result1 []container.ContainerChangeResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerDiffReturnsOnCall(i int, result1 []container.ContainerChangeResponseItem, result2 error) {
	fake.containerDiffMutex.Lock()
	defer fake.containerDiffMutex.Unlock()
	fake.ContainerDiffStub = nil
	if fake.containerDiffReturnsOnCall == nil {
		fake.containerDiffReturnsOnCall = make(map[int]struct {
			result1 []container.ContainerChangeResponseItem
			result2 error
		})
	}
	fake.containerDiffReturnsOnCall[i] = struct {
		result1 []container.ContainerChangeResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecAttach(arg1 context.Context, arg2 string, arg3 types.ExecStartCheck) (types.HijackedResponse, error) {
	fake.containerExecAttachMutex.Lock()
	ret, specificReturn := fake.containerExecAttachReturnsOnCall[len(fake.containerExecAttachArgsForCall)]
	fake.containerExecAttachArgsForCall = append(fake.containerExecAttachArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ExecStartCheck
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerExecAttach", []interface{}{arg1, arg2, arg3})
	fake.containerExecAttachMutex.Unlock()
	if fake.ContainerExecAttachStub != nil {
		return fake.ContainerExecAttachStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerExecAttachReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerExecAttachCallCount() int {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	return len(fake.containerExecAttachArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecAttachCalls(stub func(context.Context, string, types.ExecStartCheck) (types.HijackedResponse, error)) {
	fake.containerExecAttachMutex.Lock()
	defer fake.containerExecAttachMutex.Unlock()
	fake.ContainerExecAttachStub = stub
}

func (fake *fakeDockerClient) ContainerExecAttachArgsForCall(i int) (context.Context, string, types.ExecStartCheck) {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	argsForCall := fake.containerExecAttachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerExecAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.containerExecAttachMutex.Lock()
	defer fake.containerExecAttachMutex.Unlock()
	fake.ContainerExecAttachStub = nil
	fake.containerExecAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.containerExecAttachMutex.Lock()
	defer fake.containerExecAttachMutex.Unlock()
	fake.ContainerExecAttachStub = nil
	if fake.containerExecAttachReturnsOnCall == nil {
		fake.containerExecAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerExecAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecCreate(arg1 context.Context, arg2 string, arg3 types.ExecConfig) (types.IDResponse, error) {
	fake.containerExecCreateMutex.Lock()
	ret, specificReturn := fake.containerExecCreateReturnsOnCall[len(fake.containerExecCreateArgsForCall)]
	fake.containerExecCreateArgsForCall = append(fake.containerExecCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ExecConfig
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerExecCreate", []interface{}{arg1, arg2, arg3})
	fake.containerExecCreateMutex.Unlock()
	if fake.ContainerExecCreateStub != nil {
		return fake.ContainerExecCreateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerExecCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerExecCreateCallCount() int {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	return len(fake.containerExecCreateArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecCreateCalls(stub func(context.Context, string, types.ExecConfig) (types.IDResponse, error)) {
	fake.containerExecCreateMutex.Lock()
	defer fake.containerExecCreateMutex.Unlock()
	fake.ContainerExecCreateStub = stub
}

func (fake *fakeDockerClient) ContainerExecCreateArgsForCall(i int) (context.Context, string, types.ExecConfig) {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	argsForCall := fake.containerExecCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerExecCreateReturns(result1 types.IDResponse, result2 error) {
	fake.containerExecCreateMutex.Lock()
	defer fake.containerExecCreateMutex.Unlock()
	fake.ContainerExecCreateStub = nil
	fake.containerExecCreateReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecCreateReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.containerExecCreateMutex.Lock()
	defer fake.containerExecCreateMutex.Unlock()
	fake.ContainerExecCreateStub = nil
	if fake.containerExecCreateReturnsOnCall == nil {
		fake.containerExecCreateReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerExecCreateReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecInspect(arg1 context.Context, arg2 string) (types.ContainerExecInspect, error) {
	fake.containerExecInspectMutex.Lock()
	ret, specificReturn := fake.containerExecInspectReturnsOnCall[len(fake.containerExecInspectArgsForCall)]
	fake.containerExecInspectArgsForCall = append(fake.containerExecInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ContainerExecInspect", []interface{}{arg1, arg2})
	fake.containerExecInspectMutex.Unlock()
	if fake.ContainerExecInspectStub != nil {
		return fake.ContainerExecInspectStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerExecInspectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerExecInspectCallCount() int {
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	return len(fake.containerExecInspectArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecInspectCalls(stub func(context.Context, string) (types.ContainerExecInspect, error)) {
	fake.containerExecInspectMutex.Lock()
	defer fake.containerExecInspectMutex.Unlock()
	fake.ContainerExecInspectStub = stub
}

func (fake *fakeDockerClient) ContainerExecInspectArgsForCall(i int) (context.Context, string) {
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	argsForCall := fake.containerExecInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerExecInspectReturns(result1 types.ContainerExecInspect, result2 error) {
	fake.containerExecInspectMutex.Lock()
	defer fake.containerExecInspectMutex.Unlock()
	fake.ContainerExecInspectStub = nil
	fake.containerExecInspectReturns = struct {
		result1 types.ContainerExecInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecInspectReturnsOnCall(i int, result1 types.ContainerExecInspect, result2 error) {
	fake.containerExecInspectMutex.Lock()
	defer fake.containerExecInspectMutex.Unlock()
	fake.ContainerExecInspectStub = nil
	if fake.containerExecInspectReturnsOnCall == nil {
		fake.containerExecInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerExecInspect
			result2 error
		})
	}
	fake.containerExecInspectReturnsOnCall[i] = struct {
		result1 types.ContainerExecInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExecResize(arg1 context.Context, arg2 string, arg3 types.ResizeOptions) error {
	fake.containerExecResizeMutex.Lock()
	ret, specificReturn := fake.containerExecResizeReturnsOnCall[len(fake.containerExecResizeArgsForCall)]
	fake.containerExecResizeArgsForCall = append(fake.containerExecResizeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ResizeOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerExecResize", []interface{}{arg1, arg2, arg3})
	fake.containerExecResizeMutex.Unlock()
	if fake.ContainerExecResizeStub != nil {
		return fake.ContainerExecResizeStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerExecResizeReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerExecResizeCallCount() int {
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	return len(fake.containerExecResizeArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecResizeCalls(stub func(context.Context, string, types.ResizeOptions) error) {
	fake.containerExecResizeMutex.Lock()
	defer fake.containerExecResizeMutex.Unlock()
	fake.ContainerExecResizeStub = stub
}

func (fake *fakeDockerClient) ContainerExecResizeArgsForCall(i int) (context.Context, string, types.ResizeOptions) {
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	argsForCall := fake.containerExecResizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerExecResizeReturns(result1 error) {
	fake.containerExecResizeMutex.Lock()
	defer fake.containerExecResizeMutex.Unlock()
	fake.ContainerExecResizeStub = nil
	fake.containerExecResizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExecResizeReturnsOnCall(i int, result1 error) {
	fake.containerExecResizeMutex.Lock()
	defer fake.containerExecResizeMutex.Unlock()
	fake.ContainerExecResizeStub = nil
	if fake.containerExecResizeReturnsOnCall == nil {
		fake.containerExecResizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerExecResizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExecStart(arg1 context.Context, arg2 string, arg3 types.ExecStartCheck) error {
	fake.containerExecStartMutex.Lock()
	ret, specificReturn := fake.containerExecStartReturnsOnCall[len(fake.containerExecStartArgsForCall)]
	fake.containerExecStartArgsForCall = append(fake.containerExecStartArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ExecStartCheck
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerExecStart", []interface{}{arg1, arg2, arg3})
	fake.containerExecStartMutex.Unlock()
	if fake.ContainerExecStartStub != nil {
		return fake.ContainerExecStartStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerExecStartReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerExecStartCallCount() int {
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	return len(fake.containerExecStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerExecStartCalls(stub func(context.Context, string, types.ExecStartCheck) error) {
	fake.containerExecStartMutex.Lock()
	defer fake.containerExecStartMutex.Unlock()
	fake.ContainerExecStartStub = stub
}

func (fake *fakeDockerClient) ContainerExecStartArgsForCall(i int) (context.Context, string, types.ExecStartCheck) {
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	argsForCall := fake.containerExecStartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerExecStartReturns(result1 error) {
	fake.containerExecStartMutex.Lock()
	defer fake.containerExecStartMutex.Unlock()
	fake.ContainerExecStartStub = nil
	fake.containerExecStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExecStartReturnsOnCall(i int, result1 error) {
	fake.containerExecStartMutex.Lock()
	defer fake.containerExecStartMutex.Unlock()
	fake.ContainerExecStartStub = nil
	if fake.containerExecStartReturnsOnCall == nil {
		fake.containerExecStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerExecStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerExport(arg1 context.Context, arg2 string) (io.ReadCloser, error) {
	fake.containerExportMutex.Lock()
	ret, specificReturn := fake.containerExportReturnsOnCall[len(fake.containerExportArgsForCall)]
	fake.containerExportArgsForCall = append(fake.containerExportArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ContainerExport", []interface{}{arg1, arg2})
	fake.containerExportMutex.Unlock()
	if fake.ContainerExportStub != nil {
		return fake.ContainerExportStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerExportReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerExportCallCount() int {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	return len(fake.containerExportArgsForCall)
}

func (fake *fakeDockerClient) ContainerExportCalls(stub func(context.Context, string) (io.ReadCloser, error)) {
	fake.containerExportMutex.Lock()
	defer fake.containerExportMutex.Unlock()
	fake.ContainerExportStub = stub
}

func (fake *fakeDockerClient) ContainerExportArgsForCall(i int) (context.Context, string) {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	argsForCall := fake.containerExportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerExportReturns(result1 io.ReadCloser, result2 error) {
	fake.containerExportMutex.Lock()
	defer fake.containerExportMutex.Unlock()
	fake.ContainerExportStub = nil
	fake.containerExportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerExportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.containerExportMutex.Lock()
	defer fake.containerExportMutex.Unlock()
	fake.ContainerExportStub = nil
	if fake.containerExportReturnsOnCall == nil {
		fake.containerExportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerExportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspect(arg1 context.Context, arg2 string) (types.ContainerJSON, error) {
	fake.containerInspectMutex.Lock()
	ret, specificReturn := fake.containerInspectReturnsOnCall[len(fake.containerInspectArgsForCall)]
	fake.containerInspectArgsForCall = append(fake.containerInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ContainerInspect", []interface{}{arg1, arg2})
	fake.containerInspectMutex.Unlock()
	if fake.ContainerInspectStub != nil {
		return fake.ContainerInspectStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerInspectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerInspectCallCount() int {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return len(fake.containerInspectArgsForCall)
}

func (fake *fakeDockerClient) ContainerInspectCalls(stub func(context.Context, string) (types.ContainerJSON, error)) {
	fake.containerInspectMutex.Lock()
	defer fake.containerInspectMutex.Unlock()
	fake.ContainerInspectStub = stub
}

func (fake *fakeDockerClient) ContainerInspectArgsForCall(i int) (context.Context, string) {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	argsForCall := fake.containerInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerInspectReturns(result1 types.ContainerJSON, result2 error) {
	fake.containerInspectMutex.Lock()
	defer fake.containerInspectMutex.Unlock()
	fake.ContainerInspectStub = nil
	fake.containerInspectReturns = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspectReturnsOnCall(i int, result1 types.ContainerJSON, result2 error) {
	fake.containerInspectMutex.Lock()
	defer fake.containerInspectMutex.Unlock()
	fake.ContainerInspectStub = nil
	if fake.containerInspectReturnsOnCall == nil {
		fake.containerInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 error
		})
	}
	fake.containerInspectReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerInspectWithRaw(arg1 context.Context, arg2 string, arg3 bool) (types.ContainerJSON, []byte, error) {
	fake.containerInspectWithRawMutex.Lock()
	ret, specificReturn := fake.containerInspectWithRawReturnsOnCall[len(fake.containerInspectWithRawArgsForCall)]
	fake.containerInspectWithRawArgsForCall = append(fake.containerInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerInspectWithRaw", []interface{}{arg1, arg2, arg3})
	fake.containerInspectWithRawMutex.Unlock()
	if fake.ContainerInspectWithRawStub != nil {
		return fake.ContainerInspectWithRawStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.containerInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) ContainerInspectWithRawCallCount() int {
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	return len(fake.containerInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ContainerInspectWithRawCalls(stub func(context.Context, string, bool) (types.ContainerJSON, []byte, error)) {
	fake.containerInspectWithRawMutex.Lock()
	defer fake.containerInspectWithRawMutex.Unlock()
	fake.ContainerInspectWithRawStub = stub
}

func (fake *fakeDockerClient) ContainerInspectWithRawArgsForCall(i int) (context.Context, string, bool) {
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	argsForCall := fake.containerInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerInspectWithRawReturns(result1 types.ContainerJSON, result2 []byte, result3 error) {
	fake.containerInspectWithRawMutex.Lock()
	defer fake.containerInspectWithRawMutex.Unlock()
	fake.ContainerInspectWithRawStub = nil
	fake.containerInspectWithRawReturns = struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ContainerInspectWithRawReturnsOnCall(i int, result1 types.ContainerJSON, result2 []byte, result3 error) {
	fake.containerInspectWithRawMutex.Lock()
	defer fake.containerInspectWithRawMutex.Unlock()
	fake.ContainerInspectWithRawStub = nil
	if fake.containerInspectWithRawReturnsOnCall == nil {
		fake.containerInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 []byte
			result3 error
		})
	}
	fake.containerInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ContainerKill(arg1 context.Context, arg2 string, arg3 string) error {
	fake.containerKillMutex.Lock()
	ret, specificReturn := fake.containerKillReturnsOnCall[len(fake.containerKillArgsForCall)]
	fake.containerKillArgsForCall = append(fake.containerKillArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerKill", []interface{}{arg1, arg2, arg3})
	fake.containerKillMutex.Unlock()
	if fake.ContainerKillStub != nil {
		return fake.ContainerKillStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerKillReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerKillCallCount() int {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return len(fake.containerKillArgsForCall)
}

func (fake *fakeDockerClient) ContainerKillCalls(stub func(context.Context, string, string) error) {
	fake.containerKillMutex.Lock()
	defer fake.containerKillMutex.Unlock()
	fake.ContainerKillStub = stub
}

func (fake *fakeDockerClient) ContainerKillArgsForCall(i int) (context.Context, string, string) {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	argsForCall := fake.containerKillArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerKillReturns(result1 error) {
	fake.containerKillMutex.Lock()
	defer fake.containerKillMutex.Unlock()
	fake.ContainerKillStub = nil
	fake.containerKillReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerKillReturnsOnCall(i int, result1 error) {
	fake.containerKillMutex.Lock()
	defer fake.containerKillMutex.Unlock()
	fake.ContainerKillStub = nil
	if fake.containerKillReturnsOnCall == nil {
		fake.containerKillReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerKillReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerList(arg1 context.Context, arg2 types.ContainerListOptions) ([]types.Container, error) {
	fake.containerListMutex.Lock()
	ret, specificReturn := fake.containerListReturnsOnCall[len(fake.containerListArgsForCall)]
	fake.containerListArgsForCall = append(fake.containerListArgsForCall, struct {
		arg1 context.Context
		arg2 types.ContainerListOptions
	}{arg1, arg2})
	fake.recordInvocation("ContainerList", []interface{}{arg1, arg2})
	fake.containerListMutex.Unlock()
	if fake.ContainerListStub != nil {
		return fake.ContainerListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerListCallCount() int {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	return len(fake.containerListArgsForCall)
}

func (fake *fakeDockerClient) ContainerListCalls(stub func(context.Context, types.ContainerListOptions) ([]types.Container, error)) {
	fake.containerListMutex.Lock()
	defer fake.containerListMutex.Unlock()
	fake.ContainerListStub = stub
}

func (fake *fakeDockerClient) ContainerListArgsForCall(i int) (context.Context, types.ContainerListOptions) {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	argsForCall := fake.containerListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerListReturns(result1 []types.Container, result2 error) {
	fake.containerListMutex.Lock()
	defer fake.containerListMutex.Unlock()
	fake.ContainerListStub = nil
	fake.containerListReturns = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerListReturnsOnCall(i int, result1 []types.Container, result2 error) {
	fake.containerListMutex.Lock()
	defer fake.containerListMutex.Unlock()
	fake.ContainerListStub = nil
	if fake.containerListReturnsOnCall == nil {
		fake.containerListReturnsOnCall = make(map[int]struct {
			result1 []types.Container
			result2 error
		})
	}
	fake.containerListReturnsOnCall[i] = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogs(arg1 context.Context, arg2 string, arg3 types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerLogs", []interface{}{arg1, arg2, arg3})
	fake.containerLogsMutex.Unlock()
	if fake.ContainerLogsStub != nil {
		return fake.ContainerLogsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerLogsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *fakeDockerClient) ContainerLogsCalls(stub func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = stub
}

func (fake *fakeDockerClient) ContainerLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	argsForCall := fake.containerLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.containerLogsMutex.Lock()
	defer fake.containerLogsMutex.Unlock()
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerPause(arg1 context.Context, arg2 string) error {
	fake.containerPauseMutex.Lock()
	ret, specificReturn := fake.containerPauseReturnsOnCall[len(fake.containerPauseArgsForCall)]
	fake.containerPauseArgsForCall = append(fake.containerPauseArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ContainerPause", []interface{}{arg1, arg2})
	fake.containerPauseMutex.Unlock()
	if fake.ContainerPauseStub != nil {
		return fake.ContainerPauseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerPauseReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerPauseCallCount() int {
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	return len(fake.containerPauseArgsForCall)
}

func (fake *fakeDockerClient) ContainerPauseCalls(stub func(context.Context, string) error) {
	fake.containerPauseMutex.Lock()
	defer fake.containerPauseMutex.Unlock()
	fake.ContainerPauseStub = stub
}

func (fake *fakeDockerClient) ContainerPauseArgsForCall(i int) (context.Context, string) {
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	argsForCall := fake.containerPauseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerPauseReturns(result1 error) {
	fake.containerPauseMutex.Lock()
	defer fake.containerPauseMutex.Unlock()
	fake.ContainerPauseStub = nil
	fake.containerPauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerPauseReturnsOnCall(i int, result1 error) {
	fake.containerPauseMutex.Lock()
	defer fake.containerPauseMutex.Unlock()
	fake.ContainerPauseStub = nil
	if fake.containerPauseReturnsOnCall == nil {
		fake.containerPauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerPauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRemove(arg1 context.Context, arg2 string, arg3 types.ContainerRemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	ret, specificReturn := fake.containerRemoveReturnsOnCall[len(fake.containerRemoveArgsForCall)]
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerRemoveOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerRemove", []interface{}{arg1, arg2, arg3})
	fake.containerRemoveMutex.Unlock()
	if fake.ContainerRemoveStub != nil {
		return fake.ContainerRemoveStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *fakeDockerClient) ContainerRemoveCalls(stub func(context.Context, string, types.ContainerRemoveOptions) error) {
	fake.containerRemoveMutex.Lock()
	defer fake.containerRemoveMutex.Unlock()
	fake.ContainerRemoveStub = stub
}

func (fake *fakeDockerClient) ContainerRemoveArgsForCall(i int) (context.Context, string, types.ContainerRemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	argsForCall := fake.containerRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerRemoveReturns(result1 error) {
	fake.containerRemoveMutex.Lock()
	defer fake.containerRemoveMutex.Unlock()
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRemoveReturnsOnCall(i int, result1 error) {
	fake.containerRemoveMutex.Lock()
	defer fake.containerRemoveMutex.Unlock()
	fake.ContainerRemoveStub = nil
	if fake.containerRemoveReturnsOnCall == nil {
		fake.containerRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRename(arg1 context.Context, arg2 string, arg3 string) error {
	fake.containerRenameMutex.Lock()
	ret, specificReturn := fake.containerRenameReturnsOnCall[len(fake.containerRenameArgsForCall)]
	fake.containerRenameArgsForCall = append(fake.containerRenameArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerRename", []interface{}{arg1, arg2, arg3})
	fake.containerRenameMutex.Unlock()
	if fake.ContainerRenameStub != nil {
		return fake.ContainerRenameStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerRenameReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerRenameCallCount() int {
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	return len(fake.containerRenameArgsForCall)
}

func (fake *fakeDockerClient) ContainerRenameCalls(stub func(context.Context, string, string) error) {
	fake.containerRenameMutex.Lock()
	defer fake.containerRenameMutex.Unlock()
	fake.ContainerRenameStub = stub
}

func (fake *fakeDockerClient) ContainerRenameArgsForCall(i int) (context.Context, string, string) {
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	argsForCall := fake.containerRenameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerRenameReturns(result1 error) {
	fake.containerRenameMutex.Lock()
	defer fake.containerRenameMutex.Unlock()
	fake.ContainerRenameStub = nil
	fake.containerRenameReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRenameReturnsOnCall(i int, result1 error) {
	fake.containerRenameMutex.Lock()
	defer fake.containerRenameMutex.Unlock()
	fake.ContainerRenameStub = nil
	if fake.containerRenameReturnsOnCall == nil {
		fake.containerRenameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRenameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerResize(arg1 context.Context, arg2 string, arg3 types.ResizeOptions) error {
	fake.containerResizeMutex.Lock()
	ret, specificReturn := fake.containerResizeReturnsOnCall[len(fake.containerResizeArgsForCall)]
	fake.containerResizeArgsForCall = append(fake.containerResizeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ResizeOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerResize", []interface{}{arg1, arg2, arg3})
	fake.containerResizeMutex.Unlock()
	if fake.ContainerResizeStub != nil {
		return fake.ContainerResizeStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerResizeReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerResizeCallCount() int {
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	return len(fake.containerResizeArgsForCall)
}

func (fake *fakeDockerClient) ContainerResizeCalls(stub func(context.Context, string, types.ResizeOptions) error) {
	fake.containerResizeMutex.Lock()
	defer fake.containerResizeMutex.Unlock()
	fake.ContainerResizeStub = stub
}

func (fake *fakeDockerClient) ContainerResizeArgsForCall(i int) (context.Context, string, types.ResizeOptions) {
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	argsForCall := fake.containerResizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerResizeReturns(result1 error) {
	fake.containerResizeMutex.Lock()
	defer fake.containerResizeMutex.Unlock()
	fake.ContainerResizeStub = nil
	fake.containerResizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerResizeReturnsOnCall(i int, result1 error) {
	fake.containerResizeMutex.Lock()
	defer fake.containerResizeMutex.Unlock()
	fake.ContainerResizeStub = nil
	if fake.containerResizeReturnsOnCall == nil {
		fake.containerResizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerResizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRestart(arg1 context.Context, arg2 string, arg3 *time.Duration) error {
	fake.containerRestartMutex.Lock()
	ret, specificReturn := fake.containerRestartReturnsOnCall[len(fake.containerRestartArgsForCall)]
	fake.containerRestartArgsForCall = append(fake.containerRestartArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *time.Duration
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerRestart", []interface{}{arg1, arg2, arg3})
	fake.containerRestartMutex.Unlock()
	if fake.ContainerRestartStub != nil {
		return fake.ContainerRestartStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerRestartReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerRestartCallCount() int {
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	return len(fake.containerRestartArgsForCall)
}

func (fake *fakeDockerClient) ContainerRestartCalls(stub func(context.Context, string, *time.Duration) error) {
	fake.containerRestartMutex.Lock()
	defer fake.containerRestartMutex.Unlock()
	fake.ContainerRestartStub = stub
}

func (fake *fakeDockerClient) ContainerRestartArgsForCall(i int) (context.Context, string, *time.Duration) {
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	argsForCall := fake.containerRestartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerRestartReturns(result1 error) {
	fake.containerRestartMutex.Lock()
	defer fake.containerRestartMutex.Unlock()
	fake.ContainerRestartStub = nil
	fake.containerRestartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerRestartReturnsOnCall(i int, result1 error) {
	fake.containerRestartMutex.Lock()
	defer fake.containerRestartMutex.Unlock()
	fake.ContainerRestartStub = nil
	if fake.containerRestartReturnsOnCall == nil {
		fake.containerRestartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRestartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStart(arg1 context.Context, arg2 string, arg3 types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerStartOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerStart", []interface{}{arg1, arg2, arg3})
	fake.containerStartMutex.Unlock()
	if fake.ContainerStartStub != nil {
		return fake.ContainerStartStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerStartReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *fakeDockerClient) ContainerStartCalls(stub func(context.Context, string, types.ContainerStartOptions) error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = stub
}

func (fake *fakeDockerClient) ContainerStartArgsForCall(i int) (context.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	argsForCall := fake.containerStartArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerStartReturns(result1 error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.containerStartMutex.Lock()
	defer fake.containerStartMutex.Unlock()
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStatPath(arg1 context.Context, arg2 string, arg3 string) (types.ContainerPathStat, error) {
	fake.containerStatPathMutex.Lock()
	ret, specificReturn := fake.containerStatPathReturnsOnCall[len(fake.containerStatPathArgsForCall)]
	fake.containerStatPathArgsForCall = append(fake.containerStatPathArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerStatPath", []interface{}{arg1, arg2, arg3})
	fake.containerStatPathMutex.Unlock()
	if fake.ContainerStatPathStub != nil {
		return fake.ContainerStatPathStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerStatPathReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerStatPathCallCount() int {
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	return len(fake.containerStatPathArgsForCall)
}

func (fake *fakeDockerClient) ContainerStatPathCalls(stub func(context.Context, string, string) (types.ContainerPathStat, error)) {
	fake.containerStatPathMutex.Lock()
	defer fake.containerStatPathMutex.Unlock()
	fake.ContainerStatPathStub = stub
}

func (fake *fakeDockerClient) ContainerStatPathArgsForCall(i int) (context.Context, string, string) {
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	argsForCall := fake.containerStatPathArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerStatPathReturns(result1 types.ContainerPathStat, result2 error) {
	fake.containerStatPathMutex.Lock()
	defer fake.containerStatPathMutex.Unlock()
	fake.ContainerStatPathStub = nil
	fake.containerStatPathReturns = struct {
		result1 types.ContainerPathStat
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStatPathReturnsOnCall(i int, result1 types.ContainerPathStat, result2 error) {
	fake.containerStatPathMutex.Lock()
	defer fake.containerStatPathMutex.Unlock()
	fake.ContainerStatPathStub = nil
	if fake.containerStatPathReturnsOnCall == nil {
		fake.containerStatPathReturnsOnCall = make(map[int]struct {
			result1 types.ContainerPathStat
			result2 error
		})
	}
	fake.containerStatPathReturnsOnCall[i] = struct {
		result1 types.ContainerPathStat
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStats(arg1 context.Context, arg2 string, arg3 bool) (types.ContainerStats, error) {
	fake.containerStatsMutex.Lock()
	ret, specificReturn := fake.containerStatsReturnsOnCall[len(fake.containerStatsArgsForCall)]
	fake.containerStatsArgsForCall = append(fake.containerStatsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerStats", []interface{}{arg1, arg2, arg3})
	fake.containerStatsMutex.Unlock()
	if fake.ContainerStatsStub != nil {
		return fake.ContainerStatsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerStatsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerStatsCallCount() int {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	return len(fake.containerStatsArgsForCall)
}

func (fake *fakeDockerClient) ContainerStatsCalls(stub func(context.Context, string, bool) (types.ContainerStats, error)) {
	fake.containerStatsMutex.Lock()
	defer fake.containerStatsMutex.Unlock()
	fake.ContainerStatsStub = stub
}

func (fake *fakeDockerClient) ContainerStatsArgsForCall(i int) (context.Context, string, bool) {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	argsForCall := fake.containerStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerStatsReturns(result1 types.ContainerStats, result2 error) {
	fake.containerStatsMutex.Lock()
	defer fake.containerStatsMutex.Unlock()
	fake.ContainerStatsStub = nil
	fake.containerStatsReturns = struct {
		result1 types.ContainerStats
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStatsReturnsOnCall(i int, result1 types.ContainerStats, result2 error) {
	fake.containerStatsMutex.Lock()
	defer fake.containerStatsMutex.Unlock()
	fake.ContainerStatsStub = nil
	if fake.containerStatsReturnsOnCall == nil {
		fake.containerStatsReturnsOnCall = make(map[int]struct {
			result1 types.ContainerStats
			result2 error
		})
	}
	fake.containerStatsReturnsOnCall[i] = struct {
		result1 types.ContainerStats
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerStop(arg1 context.Context, arg2 string, arg3 *time.Duration) error {
	fake.containerStopMutex.Lock()
	ret, specificReturn := fake.containerStopReturnsOnCall[len(fake.containerStopArgsForCall)]
	fake.containerStopArgsForCall = append(fake.containerStopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *time.Duration
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerStop", []interface{}{arg1, arg2, arg3})
	fake.containerStopMutex.Unlock()
	if fake.ContainerStopStub != nil {
		return fake.ContainerStopStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerStopReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerStopCallCount() int {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return len(fake.containerStopArgsForCall)
}

func (fake *fakeDockerClient) ContainerStopCalls(stub func(context.Context, string, *time.Duration) error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = stub
}

func (fake *fakeDockerClient) ContainerStopArgsForCall(i int) (context.Context, string, *time.Duration) {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	argsForCall := fake.containerStopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerStopReturns(result1 error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = nil
	fake.containerStopReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerStopReturnsOnCall(i int, result1 error) {
	fake.containerStopMutex.Lock()
	defer fake.containerStopMutex.Unlock()
	fake.ContainerStopStub = nil
	if fake.containerStopReturnsOnCall == nil {
		fake.containerStopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerTop(arg1 context.Context, arg2 string, arg3 []string) (container.ContainerTopOKBody, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.containerTopMutex.Lock()
	ret, specificReturn := fake.containerTopReturnsOnCall[len(fake.containerTopArgsForCall)]
	fake.containerTopArgsForCall = append(fake.containerTopArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("ContainerTop", []interface{}{arg1, arg2, arg3Copy})
	fake.containerTopMutex.Unlock()
	if fake.ContainerTopStub != nil {
		return fake.ContainerTopStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerTopReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerTopCallCount() int {
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	return len(fake.containerTopArgsForCall)
}

func (fake *fakeDockerClient) ContainerTopCalls(stub func(context.Context, string, []string) (container.ContainerTopOKBody, error)) {
	fake.containerTopMutex.Lock()
	defer fake.containerTopMutex.Unlock()
	fake.ContainerTopStub = stub
}

func (fake *fakeDockerClient) ContainerTopArgsForCall(i int) (context.Context, string, []string) {
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	argsForCall := fake.containerTopArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerTopReturns(result1 container.ContainerTopOKBody, result2 error) {
	fake.containerTopMutex.Lock()
	defer fake.containerTopMutex.Unlock()
	fake.ContainerTopStub = nil
	fake.containerTopReturns = struct {
		result1 container.ContainerTopOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerTopReturnsOnCall(i int, result1 container.ContainerTopOKBody, result2 error) {
	fake.containerTopMutex.Lock()
	defer fake.containerTopMutex.Unlock()
	fake.ContainerTopStub = nil
	if fake.containerTopReturnsOnCall == nil {
		fake.containerTopReturnsOnCall = make(map[int]struct {
			result1 container.ContainerTopOKBody
			result2 error
		})
	}
	fake.containerTopReturnsOnCall[i] = struct {
		result1 container.ContainerTopOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerUnpause(arg1 context.Context, arg2 string) error {
	fake.containerUnpauseMutex.Lock()
	ret, specificReturn := fake.containerUnpauseReturnsOnCall[len(fake.containerUnpauseArgsForCall)]
	fake.containerUnpauseArgsForCall = append(fake.containerUnpauseArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ContainerUnpause", []interface{}{arg1, arg2})
	fake.containerUnpauseMutex.Unlock()
	if fake.ContainerUnpauseStub != nil {
		return fake.ContainerUnpauseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.containerUnpauseReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ContainerUnpauseCallCount() int {
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	return len(fake.containerUnpauseArgsForCall)
}

func (fake *fakeDockerClient) ContainerUnpauseCalls(stub func(context.Context, string) error) {
	fake.containerUnpauseMutex.Lock()
	defer fake.containerUnpauseMutex.Unlock()
	fake.ContainerUnpauseStub = stub
}

func (fake *fakeDockerClient) ContainerUnpauseArgsForCall(i int) (context.Context, string) {
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	argsForCall := fake.containerUnpauseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainerUnpauseReturns(result1 error) {
	fake.containerUnpauseMutex.Lock()
	defer fake.containerUnpauseMutex.Unlock()
	fake.ContainerUnpauseStub = nil
	fake.containerUnpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerUnpauseReturnsOnCall(i int, result1 error) {
	fake.containerUnpauseMutex.Lock()
	defer fake.containerUnpauseMutex.Unlock()
	fake.ContainerUnpauseStub = nil
	if fake.containerUnpauseReturnsOnCall == nil {
		fake.containerUnpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerUnpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ContainerUpdate(arg1 context.Context, arg2 string, arg3 container.UpdateConfig) (container.ContainerUpdateOKBody, error) {
	fake.containerUpdateMutex.Lock()
	ret, specificReturn := fake.containerUpdateReturnsOnCall[len(fake.containerUpdateArgsForCall)]
	fake.containerUpdateArgsForCall = append(fake.containerUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.UpdateConfig
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerUpdate", []interface{}{arg1, arg2, arg3})
	fake.containerUpdateMutex.Unlock()
	if fake.ContainerUpdateStub != nil {
		return fake.ContainerUpdateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerUpdateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerUpdateCallCount() int {
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	return len(fake.containerUpdateArgsForCall)
}

func (fake *fakeDockerClient) ContainerUpdateCalls(stub func(context.Context, string, container.UpdateConfig) (container.ContainerUpdateOKBody, error)) {
	fake.containerUpdateMutex.Lock()
	defer fake.containerUpdateMutex.Unlock()
	fake.ContainerUpdateStub = stub
}

func (fake *fakeDockerClient) ContainerUpdateArgsForCall(i int) (context.Context, string, container.UpdateConfig) {
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	argsForCall := fake.containerUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerUpdateReturns(result1 container.ContainerUpdateOKBody, result2 error) {
	fake.containerUpdateMutex.Lock()
	defer fake.containerUpdateMutex.Unlock()
	fake.ContainerUpdateStub = nil
	fake.containerUpdateReturns = struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerUpdateReturnsOnCall(i int, result1 container.ContainerUpdateOKBody, result2 error) {
	fake.containerUpdateMutex.Lock()
	defer fake.containerUpdateMutex.Unlock()
	fake.ContainerUpdateStub = nil
	if fake.containerUpdateReturnsOnCall == nil {
		fake.containerUpdateReturnsOnCall = make(map[int]struct {
			result1 container.ContainerUpdateOKBody
			result2 error
		})
	}
	fake.containerUpdateReturnsOnCall[i] = struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerWait(arg1 context.Context, arg2 string, arg3 container.WaitCondition) (<-chan container.ContainerWaitOKBody, <-chan error) {
	fake.containerWaitMutex.Lock()
	ret, specificReturn := fake.containerWaitReturnsOnCall[len(fake.containerWaitArgsForCall)]
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 container.WaitCondition
	}{arg1, arg2, arg3})
	fake.recordInvocation("ContainerWait", []interface{}{arg1, arg2, arg3})
	fake.containerWaitMutex.Unlock()
	if fake.ContainerWaitStub != nil {
		return fake.ContainerWaitStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containerWaitReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *fakeDockerClient) ContainerWaitCalls(stub func(context.Context, string, container.WaitCondition) (<-chan container.ContainerWaitOKBody, <-chan error)) {
	fake.containerWaitMutex.Lock()
	defer fake.containerWaitMutex.Unlock()
	fake.ContainerWaitStub = stub
}

func (fake *fakeDockerClient) ContainerWaitArgsForCall(i int) (context.Context, string, container.WaitCondition) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	argsForCall := fake.containerWaitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ContainerWaitReturns(result1 <-chan container.ContainerWaitOKBody, result2 <-chan error) {
	fake.containerWaitMutex.Lock()
	defer fake.containerWaitMutex.Unlock()
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 <-chan container.ContainerWaitOKBody
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainerWaitReturnsOnCall(i int, result1 <-chan container.ContainerWaitOKBody, result2 <-chan error) {
	fake.containerWaitMutex.Lock()
	defer fake.containerWaitMutex.Unlock()
	fake.ContainerWaitStub = nil
	if fake.containerWaitReturnsOnCall == nil {
		fake.containerWaitReturnsOnCall = make(map[int]struct {
			result1 <-chan container.ContainerWaitOKBody
			result2 <-chan error
		})
	}
	fake.containerWaitReturnsOnCall[i] = struct {
		result1 <-chan container.ContainerWaitOKBody
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainersPrune(arg1 context.Context, arg2 filters.Args) (types.ContainersPruneReport, error) {
	fake.containersPruneMutex.Lock()
	ret, specificReturn := fake.containersPruneReturnsOnCall[len(fake.containersPruneArgsForCall)]
	fake.containersPruneArgsForCall = append(fake.containersPruneArgsForCall, struct {
		arg1 context.Context
		arg2 filters.Args
	}{arg1, arg2})
	fake.recordInvocation("ContainersPrune", []interface{}{arg1, arg2})
	fake.containersPruneMutex.Unlock()
	if fake.ContainersPruneStub != nil {
		return fake.ContainersPruneStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.containersPruneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ContainersPruneCallCount() int {
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	return len(fake.containersPruneArgsForCall)
}

func (fake *fakeDockerClient) ContainersPruneCalls(stub func(context.Context, filters.Args) (types.ContainersPruneReport, error)) {
	fake.containersPruneMutex.Lock()
	defer fake.containersPruneMutex.Unlock()
	fake.ContainersPruneStub = stub
}

func (fake *fakeDockerClient) ContainersPruneArgsForCall(i int) (context.Context, filters.Args) {
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	argsForCall := fake.containersPruneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ContainersPruneReturns(result1 types.ContainersPruneReport, result2 error) {
	fake.containersPruneMutex.Lock()
	defer fake.containersPruneMutex.Unlock()
	fake.ContainersPruneStub = nil
	fake.containersPruneReturns = struct {
		result1 types.ContainersPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ContainersPruneReturnsOnCall(i int, result1 types.ContainersPruneReport, result2 error) {
	fake.containersPruneMutex.Lock()
	defer fake.containersPruneMutex.Unlock()
	fake.ContainersPruneStub = nil
	if fake.containersPruneReturnsOnCall == nil {
		fake.containersPruneReturnsOnCall = make(map[int]struct {
			result1 types.ContainersPruneReport
			result2 error
		})
	}
	fake.containersPruneReturnsOnCall[i] = struct {
		result1 types.ContainersPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) CopyFromContainer(arg1 context.Context, arg2 string, arg3 string) (io.ReadCloser, types.ContainerPathStat, error) {
	fake.copyFromContainerMutex.Lock()
	ret, specificReturn := fake.copyFromContainerReturnsOnCall[len(fake.copyFromContainerArgsForCall)]
	fake.copyFromContainerArgsForCall = append(fake.copyFromContainerArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("CopyFromContainer", []interface{}{arg1, arg2, arg3})
	fake.copyFromContainerMutex.Unlock()
	if fake.CopyFromContainerStub != nil {
		return fake.CopyFromContainerStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.copyFromContainerReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) CopyFromContainerCallCount() int {
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	return len(fake.copyFromContainerArgsForCall)
}

func (fake *fakeDockerClient) CopyFromContainerCalls(stub func(context.Context, string, string) (io.ReadCloser, types.ContainerPathStat, error)) {
	fake.copyFromContainerMutex.Lock()
	defer fake.copyFromContainerMutex.Unlock()
	fake.CopyFromContainerStub = stub
}

func (fake *fakeDockerClient) CopyFromContainerArgsForCall(i int) (context.Context, string, string) {
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	argsForCall := fake.copyFromContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) CopyFromContainerReturns(result1 io.ReadCloser, result2 types.ContainerPathStat, result3 error) {
	fake.copyFromContainerMutex.Lock()
	defer fake.copyFromContainerMutex.Unlock()
	fake.CopyFromContainerStub = nil
	fake.copyFromContainerReturns = struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) CopyFromContainerReturnsOnCall(i int, result1 io.ReadCloser, result2 types.ContainerPathStat, result3 error) {
	fake.copyFromContainerMutex.Lock()
	defer fake.copyFromContainerMutex.Unlock()
	fake.CopyFromContainerStub = nil
	if fake.copyFromContainerReturnsOnCall == nil {
		fake.copyFromContainerReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 types.ContainerPathStat
			result3 error
		})
	}
	fake.copyFromContainerReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) CopyToContainer(arg1 context.Context, arg2 string, arg3 string, arg4 io.Reader, arg5 types.CopyToContainerOptions) error {
	fake.copyToContainerMutex.Lock()
	ret, specificReturn := fake.copyToContainerReturnsOnCall[len(fake.copyToContainerArgsForCall)]
	fake.copyToContainerArgsForCall = append(fake.copyToContainerArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 io.Reader
		arg5 types.CopyToContainerOptions
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("CopyToContainer", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.copyToContainerMutex.Unlock()
	if fake.CopyToContainerStub != nil {
		return fake.CopyToContainerStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.copyToContainerReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) CopyToContainerCallCount() int {
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	return len(fake.copyToContainerArgsForCall)
}

func (fake *fakeDockerClient) CopyToContainerCalls(stub func(context.Context, string, string, io.Reader, types.CopyToContainerOptions) error) {
	fake.copyToContainerMutex.Lock()
	defer fake.copyToContainerMutex.Unlock()
	fake.CopyToContainerStub = stub
}

func (fake *fakeDockerClient) CopyToContainerArgsForCall(i int) (context.Context, string, string, io.Reader, types.CopyToContainerOptions) {
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	argsForCall := fake.copyToContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *fakeDockerClient) CopyToContainerReturns(result1 error) {
	fake.copyToContainerMutex.Lock()
	defer fake.copyToContainerMutex.Unlock()
	fake.CopyToContainerStub = nil
	fake.copyToContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) CopyToContainerReturnsOnCall(i int, result1 error) {
	fake.copyToContainerMutex.Lock()
	defer fake.copyToContainerMutex.Unlock()
	fake.CopyToContainerStub = nil
	if fake.copyToContainerReturnsOnCall == nil {
		fake.copyToContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyToContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) DaemonHost() string {
	fake.daemonHostMutex.Lock()
	ret, specificReturn := fake.daemonHostReturnsOnCall[len(fake.daemonHostArgsForCall)]
	fake.daemonHostArgsForCall = append(fake.daemonHostArgsForCall, struct {
	}{})
	fake.recordInvocation("DaemonHost", []interface{}{})
	fake.daemonHostMutex.Unlock()
	if fake.DaemonHostStub != nil {
		return fake.DaemonHostStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.daemonHostReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) DaemonHostCallCount() int {
	fake.daemonHostMutex.RLock()
	defer fake.daemonHostMutex.RUnlock()
	return len(fake.daemonHostArgsForCall)
}

func (fake *fakeDockerClient) DaemonHostCalls(stub func() string) {
	fake.daemonHostMutex.Lock()
	defer fake.daemonHostMutex.Unlock()
	fake.DaemonHostStub = stub
}

func (fake *fakeDockerClient) DaemonHostReturns(result1 string) {
	fake.daemonHostMutex.Lock()
	defer fake.daemonHostMutex.Unlock()
	fake.DaemonHostStub = nil
	fake.daemonHostReturns = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) DaemonHostReturnsOnCall(i int, result1 string) {
	fake.daemonHostMutex.Lock()
	defer fake.daemonHostMutex.Unlock()
	fake.DaemonHostStub = nil
	if fake.daemonHostReturnsOnCall == nil {
		fake.daemonHostReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.daemonHostReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *fakeDockerClient) DialSession(arg1 context.Context, arg2 string, arg3 map[string][]string) (net.Conn, error) {
	fake.dialSessionMutex.Lock()
	ret, specificReturn := fake.dialSessionReturnsOnCall[len(fake.dialSessionArgsForCall)]
	fake.dialSessionArgsForCall = append(fake.dialSessionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string][]string
	}{arg1, arg2, arg3})
	fake.recordInvocation("DialSession", []interface{}{arg1, arg2, arg3})
	fake.dialSessionMutex.Unlock()
	if fake.DialSessionStub != nil {
		return fake.DialSessionStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.dialSessionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) DialSessionCallCount() int {
	fake.dialSessionMutex.RLock()
	defer fake.dialSessionMutex.RUnlock()
	return len(fake.dialSessionArgsForCall)
}

func (fake *fakeDockerClient) DialSessionCalls(stub func(context.Context, string, map[string][]string) (net.Conn, error)) {
	fake.dialSessionMutex.Lock()
	defer fake.dialSessionMutex.Unlock()
	fake.DialSessionStub = stub
}

func (fake *fakeDockerClient) DialSessionArgsForCall(i int) (context.Context, string, map[string][]string) {
	fake.dialSessionMutex.RLock()
	defer fake.dialSessionMutex.RUnlock()
	argsForCall := fake.dialSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) DialSessionReturns(result1 net.Conn, result2 error) {
	fake.dialSessionMutex.Lock()
	defer fake.dialSessionMutex.Unlock()
	fake.DialSessionStub = nil
	fake.dialSessionReturns = struct {
		result1 net.Conn
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DialSessionReturnsOnCall(i int, result1 net.Conn, result2 error) {
	fake.dialSessionMutex.Lock()
	defer fake.dialSessionMutex.Unlock()
	fake.DialSessionStub = nil
	if fake.dialSessionReturnsOnCall == nil {
		fake.dialSessionReturnsOnCall = make(map[int]struct {
			result1 net.Conn
			result2 error
		})
	}
	fake.dialSessionReturnsOnCall[i] = struct {
		result1 net.Conn
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Dialer() func(context.Context) (net.Conn, error) {
	fake.dialerMutex.Lock()
	ret, specificReturn := fake.dialerReturnsOnCall[len(fake.dialerArgsForCall)]
	fake.dialerArgsForCall = append(fake.dialerArgsForCall, struct {
	}{})
	fake.recordInvocation("Dialer", []interface{}{})
	fake.dialerMutex.Unlock()
	if fake.DialerStub != nil {
		return fake.DialerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dialerReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) DialerCallCount() int {
	fake.dialerMutex.RLock()
	defer fake.dialerMutex.RUnlock()
	return len(fake.dialerArgsForCall)
}

func (fake *fakeDockerClient) DialerCalls(stub func() func(context.Context) (net.Conn, error)) {
	fake.dialerMutex.Lock()
	defer fake.dialerMutex.Unlock()
	fake.DialerStub = stub
}

func (fake *fakeDockerClient) DialerReturns(result1 func(context.Context) (net.Conn, error)) {
	fake.dialerMutex.Lock()
	defer fake.dialerMutex.Unlock()
	fake.DialerStub = nil
	fake.dialerReturns = struct {
		result1 func(context.Context) (net.Conn, error)
	}{result1}
}

func (fake *fakeDockerClient) DialerReturnsOnCall(i int, result1 func(context.Context) (net.Conn, error)) {
	fake.dialerMutex.Lock()
	defer fake.dialerMutex.Unlock()
	fake.DialerStub = nil
	if fake.dialerReturnsOnCall == nil {
		fake.dialerReturnsOnCall = make(map[int]struct {
			result1 func(context.Context) (net.Conn, error)
		})
	}
	fake.dialerReturnsOnCall[i] = struct {
		result1 func(context.Context) (net.Conn, error)
	}{result1}
}

func (fake *fakeDockerClient) DiskUsage(arg1 context.Context) (types.DiskUsage, error) {
	fake.diskUsageMutex.Lock()
	ret, specificReturn := fake.diskUsageReturnsOnCall[len(fake.diskUsageArgsForCall)]
	fake.diskUsageArgsForCall = append(fake.diskUsageArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("DiskUsage", []interface{}{arg1})
	fake.diskUsageMutex.Unlock()
	if fake.DiskUsageStub != nil {
		return fake.DiskUsageStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.diskUsageReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) DiskUsageCallCount() int {
	fake.diskUsageMutex.RLock()
	defer fake.diskUsageMutex.RUnlock()
	return len(fake.diskUsageArgsForCall)
}

func (fake *fakeDockerClient) DiskUsageCalls(stub func(context.Context) (types.DiskUsage, error)) {
	fake.diskUsageMutex.Lock()
	defer fake.diskUsageMutex.Unlock()
	fake.DiskUsageStub = stub
}

func (fake *fakeDockerClient) DiskUsageArgsForCall(i int) context.Context {
	fake.diskUsageMutex.RLock()
	defer fake.diskUsageMutex.RUnlock()
	argsForCall := fake.diskUsageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) DiskUsageReturns(result1 types.DiskUsage, result2 error) {
	fake.diskUsageMutex.Lock()
	defer fake.diskUsageMutex.Unlock()
	fake.DiskUsageStub = nil
	fake.diskUsageReturns = struct {
		result1 types.DiskUsage
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DiskUsageReturnsOnCall(i int, result1 types.DiskUsage, result2 error) {
	fake.diskUsageMutex.Lock()
	defer fake.diskUsageMutex.Unlock()
	fake.DiskUsageStub = nil
	if fake.diskUsageReturnsOnCall == nil {
		fake.diskUsageReturnsOnCall = make(map[int]struct {
			result1 types.DiskUsage
			result2 error
		})
	}
	fake.diskUsageReturnsOnCall[i] = struct {
		result1 types.DiskUsage
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DistributionInspect(arg1 context.Context, arg2 string, arg3 string) (registry.DistributionInspect, error) {
	fake.distributionInspectMutex.Lock()
	ret, specificReturn := fake.distributionInspectReturnsOnCall[len(fake.distributionInspectArgsForCall)]
	fake.distributionInspectArgsForCall = append(fake.distributionInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("DistributionInspect", []interface{}{arg1, arg2, arg3})
	fake.distributionInspectMutex.Unlock()
	if fake.DistributionInspectStub != nil {
		return fake.DistributionInspectStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.distributionInspectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) DistributionInspectCallCount() int {
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	return len(fake.distributionInspectArgsForCall)
}

func (fake *fakeDockerClient) DistributionInspectCalls(stub func(context.Context, string, string) (registry.DistributionInspect, error)) {
	fake.distributionInspectMutex.Lock()
	defer fake.distributionInspectMutex.Unlock()
	fake.DistributionInspectStub = stub
}

func (fake *fakeDockerClient) DistributionInspectArgsForCall(i int) (context.Context, string, string) {
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	argsForCall := fake.distributionInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) DistributionInspectReturns(result1 registry.DistributionInspect, result2 error) {
	fake.distributionInspectMutex.Lock()
	defer fake.distributionInspectMutex.Unlock()
	fake.DistributionInspectStub = nil
	fake.distributionInspectReturns = struct {
		result1 registry.DistributionInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) DistributionInspectReturnsOnCall(i int, result1 registry.DistributionInspect, result2 error) {
	fake.distributionInspectMutex.Lock()
	defer fake.distributionInspectMutex.Unlock()
	fake.DistributionInspectStub = nil
	if fake.distributionInspectReturnsOnCall == nil {
		fake.distributionInspectReturnsOnCall = make(map[int]struct {
			result1 registry.DistributionInspect
			result2 error
		})
	}
	fake.distributionInspectReturnsOnCall[i] = struct {
		result1 registry.DistributionInspect
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Events(arg1 context.Context, arg2 types.EventsOptions) (<-chan events.Message, <-chan error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 context.Context
		arg2 types.EventsOptions
	}{arg1, arg2})
	fake.recordInvocation("Events", []interface{}{arg1, arg2})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.eventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *fakeDockerClient) EventsCalls(stub func(context.Context, types.EventsOptions) (<-chan events.Message, <-chan error)) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *fakeDockerClient) EventsArgsForCall(i int) (context.Context, types.EventsOptions) {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) EventsReturns(result1 <-chan events.Message, result2 <-chan error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 <-chan events.Message
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) EventsReturnsOnCall(i int, result1 <-chan events.Message, result2 <-chan error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 <-chan events.Message
			result2 <-chan error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 <-chan events.Message
		result2 <-chan error
	}{result1, result2}
}

func (fake *fakeDockerClient) HTTPClient() *http.Client {
	fake.hTTPClientMutex.Lock()
	ret, specificReturn := fake.hTTPClientReturnsOnCall[len(fake.hTTPClientArgsForCall)]
	fake.hTTPClientArgsForCall = append(fake.hTTPClientArgsForCall, struct {
	}{})
	fake.recordInvocation("HTTPClient", []interface{}{})
	fake.hTTPClientMutex.Unlock()
	if fake.HTTPClientStub != nil {
		return fake.HTTPClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hTTPClientReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) HTTPClientCallCount() int {
	fake.hTTPClientMutex.RLock()
	defer fake.hTTPClientMutex.RUnlock()
	return len(fake.hTTPClientArgsForCall)
}

func (fake *fakeDockerClient) HTTPClientCalls(stub func() *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = stub
}

func (fake *fakeDockerClient) HTTPClientReturns(result1 *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = nil
	fake.hTTPClientReturns = struct {
		result1 *http.Client
	}{result1}
}

func (fake *fakeDockerClient) HTTPClientReturnsOnCall(i int, result1 *http.Client) {
	fake.hTTPClientMutex.Lock()
	defer fake.hTTPClientMutex.Unlock()
	fake.HTTPClientStub = nil
	if fake.hTTPClientReturnsOnCall == nil {
		fake.hTTPClientReturnsOnCall = make(map[int]struct {
			result1 *http.Client
		})
	}
	fake.hTTPClientReturnsOnCall[i] = struct {
		result1 *http.Client
	}{result1}
}

func (fake *fakeDockerClient) ImageBuild(arg1 context.Context, arg2 io.Reader, arg3 types.ImageBuildOptions) (types.ImageBuildResponse, error) {
	fake.imageBuildMutex.Lock()
	ret, specificReturn := fake.imageBuildReturnsOnCall[len(fake.imageBuildArgsForCall)]
	fake.imageBuildArgsForCall = append(fake.imageBuildArgsForCall, struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 types.ImageBuildOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImageBuild", []interface{}{arg1, arg2, arg3})
	fake.imageBuildMutex.Unlock()
	if fake.ImageBuildStub != nil {
		return fake.ImageBuildStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageBuildCallCount() int {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	return len(fake.imageBuildArgsForCall)
}

func (fake *fakeDockerClient) ImageBuildCalls(stub func(context.Context, io.Reader, types.ImageBuildOptions) (types.ImageBuildResponse, error)) {
	fake.imageBuildMutex.Lock()
	defer fake.imageBuildMutex.Unlock()
	fake.ImageBuildStub = stub
}

func (fake *fakeDockerClient) ImageBuildArgsForCall(i int) (context.Context, io.Reader, types.ImageBuildOptions) {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	argsForCall := fake.imageBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImageBuildReturns(result1 types.ImageBuildResponse, result2 error) {
	fake.imageBuildMutex.Lock()
	defer fake.imageBuildMutex.Unlock()
	fake.ImageBuildStub = nil
	fake.imageBuildReturns = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageBuildReturnsOnCall(i int, result1 types.ImageBuildResponse, result2 error) {
	fake.imageBuildMutex.Lock()
	defer fake.imageBuildMutex.Unlock()
	fake.ImageBuildStub = nil
	if fake.imageBuildReturnsOnCall == nil {
		fake.imageBuildReturnsOnCall = make(map[int]struct {
			result1 types.ImageBuildResponse
			result2 error
		})
	}
	fake.imageBuildReturnsOnCall[i] = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageCreate(arg1 context.Context, arg2 string, arg3 types.ImageCreateOptions) (io.ReadCloser, error) {
	fake.imageCreateMutex.Lock()
	ret, specificReturn := fake.imageCreateReturnsOnCall[len(fake.imageCreateArgsForCall)]
	fake.imageCreateArgsForCall = append(fake.imageCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImageCreateOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImageCreate", []interface{}{arg1, arg2, arg3})
	fake.imageCreateMutex.Unlock()
	if fake.ImageCreateStub != nil {
		return fake.ImageCreateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageCreateCallCount() int {
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	return len(fake.imageCreateArgsForCall)
}

func (fake *fakeDockerClient) ImageCreateCalls(stub func(context.Context, string, types.ImageCreateOptions) (io.ReadCloser, error)) {
	fake.imageCreateMutex.Lock()
	defer fake.imageCreateMutex.Unlock()
	fake.ImageCreateStub = stub
}

func (fake *fakeDockerClient) ImageCreateArgsForCall(i int) (context.Context, string, types.ImageCreateOptions) {
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	argsForCall := fake.imageCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImageCreateReturns(result1 io.ReadCloser, result2 error) {
	fake.imageCreateMutex.Lock()
	defer fake.imageCreateMutex.Unlock()
	fake.ImageCreateStub = nil
	fake.imageCreateReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageCreateReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imageCreateMutex.Lock()
	defer fake.imageCreateMutex.Unlock()
	fake.ImageCreateStub = nil
	if fake.imageCreateReturnsOnCall == nil {
		fake.imageCreateReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageCreateReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageHistory(arg1 context.Context, arg2 string) ([]image.HistoryResponseItem, error) {
	fake.imageHistoryMutex.Lock()
	ret, specificReturn := fake.imageHistoryReturnsOnCall[len(fake.imageHistoryArgsForCall)]
	fake.imageHistoryArgsForCall = append(fake.imageHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ImageHistory", []interface{}{arg1, arg2})
	fake.imageHistoryMutex.Unlock()
	if fake.ImageHistoryStub != nil {
		return fake.ImageHistoryStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageHistoryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageHistoryCallCount() int {
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	return len(fake.imageHistoryArgsForCall)
}

func (fake *fakeDockerClient) ImageHistoryCalls(stub func(context.Context, string) ([]image.HistoryResponseItem, error)) {
	fake.imageHistoryMutex.Lock()
	defer fake.imageHistoryMutex.Unlock()
	fake.ImageHistoryStub = stub
}

func (fake *fakeDockerClient) ImageHistoryArgsForCall(i int) (context.Context, string) {
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	argsForCall := fake.imageHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ImageHistoryReturns(result1 []image.HistoryResponseItem, result2 error) {
	fake.imageHistoryMutex.Lock()
	defer fake.imageHistoryMutex.Unlock()
	fake.ImageHistoryStub = nil
	fake.imageHistoryReturns = struct {
		result1 []image.HistoryResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageHistoryReturnsOnCall(i int, result1 []image.HistoryResponseItem, result2 error) {
	fake.imageHistoryMutex.Lock()
	defer fake.imageHistoryMutex.Unlock()
	fake.ImageHistoryStub = nil
	if fake.imageHistoryReturnsOnCall == nil {
		fake.imageHistoryReturnsOnCall = make(map[int]struct {
			result1 []image.HistoryResponseItem
			result2 error
		})
	}
	fake.imageHistoryReturnsOnCall[i] = struct {
		result1 []image.HistoryResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageImport(arg1 context.Context, arg2 types.ImageImportSource, arg3 string, arg4 types.ImageImportOptions) (io.ReadCloser, error) {
	fake.imageImportMutex.Lock()
	ret, specificReturn := fake.imageImportReturnsOnCall[len(fake.imageImportArgsForCall)]
	fake.imageImportArgsForCall = append(fake.imageImportArgsForCall, struct {
		arg1 context.Context
		arg2 types.ImageImportSource
		arg3 string
		arg4 types.ImageImportOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ImageImport", []interface{}{arg1, arg2, arg3, arg4})
	fake.imageImportMutex.Unlock()
	if fake.ImageImportStub != nil {
		return fake.ImageImportStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageImportReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageImportCallCount() int {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	return len(fake.imageImportArgsForCall)
}

func (fake *fakeDockerClient) ImageImportCalls(stub func(context.Context, types.ImageImportSource, string, types.ImageImportOptions) (io.ReadCloser, error)) {
	fake.imageImportMutex.Lock()
	defer fake.imageImportMutex.Unlock()
	fake.ImageImportStub = stub
}

func (fake *fakeDockerClient) ImageImportArgsForCall(i int) (context.Context, types.ImageImportSource, string, types.ImageImportOptions) {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	argsForCall := fake.imageImportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) ImageImportReturns(result1 io.ReadCloser, result2 error) {
	fake.imageImportMutex.Lock()
	defer fake.imageImportMutex.Unlock()
	fake.ImageImportStub = nil
	fake.imageImportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageImportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imageImportMutex.Lock()
	defer fake.imageImportMutex.Unlock()
	fake.ImageImportStub = nil
	if fake.imageImportReturnsOnCall == nil {
		fake.imageImportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageImportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageInspectWithRaw(arg1 context.Context, arg2 string) (types.ImageInspect, []byte, error) {
	fake.imageInspectWithRawMutex.Lock()
	ret, specificReturn := fake.imageInspectWithRawReturnsOnCall[len(fake.imageInspectWithRawArgsForCall)]
	fake.imageInspectWithRawArgsForCall = append(fake.imageInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ImageInspectWithRaw", []interface{}{arg1, arg2})
	fake.imageInspectWithRawMutex.Unlock()
	if fake.ImageInspectWithRawStub != nil {
		return fake.ImageInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.imageInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) ImageInspectWithRawCallCount() int {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	return len(fake.imageInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ImageInspectWithRawCalls(stub func(context.Context, string) (types.ImageInspect, []byte, error)) {
	fake.imageInspectWithRawMutex.Lock()
	defer fake.imageInspectWithRawMutex.Unlock()
	fake.ImageInspectWithRawStub = stub
}

func (fake *fakeDockerClient) ImageInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	argsForCall := fake.imageInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ImageInspectWithRawReturns(result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.imageInspectWithRawMutex.Lock()
	defer fake.imageInspectWithRawMutex.Unlock()
	fake.ImageInspectWithRawStub = nil
	fake.imageInspectWithRawReturns = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ImageInspectWithRawReturnsOnCall(i int, result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.imageInspectWithRawMutex.Lock()
	defer fake.imageInspectWithRawMutex.Unlock()
	fake.ImageInspectWithRawStub = nil
	if fake.imageInspectWithRawReturnsOnCall == nil {
		fake.imageInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ImageInspect
			result2 []byte
			result3 error
		})
	}
	fake.imageInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ImageList(arg1 context.Context, arg2 types.ImageListOptions) ([]types.ImageSummary, error) {
	fake.imageListMutex.Lock()
	ret, specificReturn := fake.imageListReturnsOnCall[len(fake.imageListArgsForCall)]
	fake.imageListArgsForCall = append(fake.imageListArgsForCall, struct {
		arg1 context.Context
		arg2 types.ImageListOptions
	}{arg1, arg2})
	fake.recordInvocation("ImageList", []interface{}{arg1, arg2})
	fake.imageListMutex.Unlock()
	if fake.ImageListStub != nil {
		return fake.ImageListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageListCallCount() int {
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	return len(fake.imageListArgsForCall)
}

func (fake *fakeDockerClient) ImageListCalls(stub func(context.Context, types.ImageListOptions) ([]types.ImageSummary, error)) {
	fake.imageListMutex.Lock()
	defer fake.imageListMutex.Unlock()
	fake.ImageListStub = stub
}

func (fake *fakeDockerClient) ImageListArgsForCall(i int) (context.Context, types.ImageListOptions) {
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	argsForCall := fake.imageListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ImageListReturns(result1 []types.ImageSummary, result2 error) {
	fake.imageListMutex.Lock()
	defer fake.imageListMutex.Unlock()
	fake.ImageListStub = nil
	fake.imageListReturns = struct {
		result1 []types.ImageSummary
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageListReturnsOnCall(i int, result1 []types.ImageSummary, result2 error) {
	fake.imageListMutex.Lock()
	defer fake.imageListMutex.Unlock()
	fake.ImageListStub = nil
	if fake.imageListReturnsOnCall == nil {
		fake.imageListReturnsOnCall = make(map[int]struct {
			result1 []types.ImageSummary
			result2 error
		})
	}
	fake.imageListReturnsOnCall[i] = struct {
		result1 []types.ImageSummary
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageLoad(arg1 context.Context, arg2 io.Reader, arg3 bool) (types.ImageLoadResponse, error) {
	fake.imageLoadMutex.Lock()
	ret, specificReturn := fake.imageLoadReturnsOnCall[len(fake.imageLoadArgsForCall)]
	fake.imageLoadArgsForCall = append(fake.imageLoadArgsForCall, struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImageLoad", []interface{}{arg1, arg2, arg3})
	fake.imageLoadMutex.Unlock()
	if fake.ImageLoadStub != nil {
		return fake.ImageLoadStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageLoadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageLoadCallCount() int {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	return len(fake.imageLoadArgsForCall)
}

func (fake *fakeDockerClient) ImageLoadCalls(stub func(context.Context, io.Reader, bool) (types.ImageLoadResponse, error)) {
	fake.imageLoadMutex.Lock()
	defer fake.imageLoadMutex.Unlock()
	fake.ImageLoadStub = stub
}

func (fake *fakeDockerClient) ImageLoadArgsForCall(i int) (context.Context, io.Reader, bool) {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	argsForCall := fake.imageLoadArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImageLoadReturns(result1 types.ImageLoadResponse, result2 error) {
	fake.imageLoadMutex.Lock()
	defer fake.imageLoadMutex.Unlock()
	fake.ImageLoadStub = nil
	fake.imageLoadReturns = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageLoadReturnsOnCall(i int, result1 types.ImageLoadResponse, result2 error) {
	fake.imageLoadMutex.Lock()
	defer fake.imageLoadMutex.Unlock()
	fake.ImageLoadStub = nil
	if fake.imageLoadReturnsOnCall == nil {
		fake.imageLoadReturnsOnCall = make(map[int]struct {
			result1 types.ImageLoadResponse
			result2 error
		})
	}
	fake.imageLoadReturnsOnCall[i] = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePull(arg1 context.Context, arg2 string, arg3 types.ImagePullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	ret, specificReturn := fake.imagePullReturnsOnCall[len(fake.imagePullArgsForCall)]
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImagePullOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImagePull", []interface{}{arg1, arg2, arg3})
	fake.imagePullMutex.Unlock()
	if fake.ImagePullStub != nil {
		return fake.ImagePullStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imagePullReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *fakeDockerClient) ImagePullCalls(stub func(context.Context, string, types.ImagePullOptions) (io.ReadCloser, error)) {
	fake.imagePullMutex.Lock()
	defer fake.imagePullMutex.Unlock()
	fake.ImagePullStub = stub
}

func (fake *fakeDockerClient) ImagePullArgsForCall(i int) (context.Context, string, types.ImagePullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	argsForCall := fake.imagePullArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.imagePullMutex.Lock()
	defer fake.imagePullMutex.Unlock()
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePullReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imagePullMutex.Lock()
	defer fake.imagePullMutex.Unlock()
	fake.ImagePullStub = nil
	if fake.imagePullReturnsOnCall == nil {
		fake.imagePullReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePullReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePush(arg1 context.Context, arg2 string, arg3 types.ImagePushOptions) (io.ReadCloser, error) {
	fake.imagePushMutex.Lock()
	ret, specificReturn := fake.imagePushReturnsOnCall[len(fake.imagePushArgsForCall)]
	fake.imagePushArgsForCall = append(fake.imagePushArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImagePushOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImagePush", []interface{}{arg1, arg2, arg3})
	fake.imagePushMutex.Unlock()
	if fake.ImagePushStub != nil {
		return fake.ImagePushStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imagePushReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImagePushCallCount() int {
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	return len(fake.imagePushArgsForCall)
}

func (fake *fakeDockerClient) ImagePushCalls(stub func(context.Context, string, types.ImagePushOptions) (io.ReadCloser, error)) {
	fake.imagePushMutex.Lock()
	defer fake.imagePushMutex.Unlock()
	fake.ImagePushStub = stub
}

func (fake *fakeDockerClient) ImagePushArgsForCall(i int) (context.Context, string, types.ImagePushOptions) {
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	argsForCall := fake.imagePushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImagePushReturns(result1 io.ReadCloser, result2 error) {
	fake.imagePushMutex.Lock()
	defer fake.imagePushMutex.Unlock()
	fake.ImagePushStub = nil
	fake.imagePushReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagePushReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imagePushMutex.Lock()
	defer fake.imagePushMutex.Unlock()
	fake.ImagePushStub = nil
	if fake.imagePushReturnsOnCall == nil {
		fake.imagePushReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePushReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageRemove(arg1 context.Context, arg2 string, arg3 types.ImageRemoveOptions) ([]types.ImageDeleteResponseItem, error) {
	fake.imageRemoveMutex.Lock()
	ret, specificReturn := fake.imageRemoveReturnsOnCall[len(fake.imageRemoveArgsForCall)]
	fake.imageRemoveArgsForCall = append(fake.imageRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImageRemoveOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImageRemove", []interface{}{arg1, arg2, arg3})
	fake.imageRemoveMutex.Unlock()
	if fake.ImageRemoveStub != nil {
		return fake.ImageRemoveStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageRemoveReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageRemoveCallCount() int {
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	return len(fake.imageRemoveArgsForCall)
}

func (fake *fakeDockerClient) ImageRemoveCalls(stub func(context.Context, string, types.ImageRemoveOptions) ([]types.ImageDeleteResponseItem, error)) {
	fake.imageRemoveMutex.Lock()
	defer fake.imageRemoveMutex.Unlock()
	fake.ImageRemoveStub = stub
}

func (fake *fakeDockerClient) ImageRemoveArgsForCall(i int) (context.Context, string, types.ImageRemoveOptions) {
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	argsForCall := fake.imageRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImageRemoveReturns(result1 []types.ImageDeleteResponseItem, result2 error) {
	fake.imageRemoveMutex.Lock()
	defer fake.imageRemoveMutex.Unlock()
	fake.ImageRemoveStub = nil
	fake.imageRemoveReturns = struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageRemoveReturnsOnCall(i int, result1 []types.ImageDeleteResponseItem, result2 error) {
	fake.imageRemoveMutex.Lock()
	defer fake.imageRemoveMutex.Unlock()
	fake.ImageRemoveStub = nil
	if fake.imageRemoveReturnsOnCall == nil {
		fake.imageRemoveReturnsOnCall = make(map[int]struct {
			result1 []types.ImageDeleteResponseItem
			result2 error
		})
	}
	fake.imageRemoveReturnsOnCall[i] = struct {
		result1 []types.ImageDeleteResponseItem
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSave(arg1 context.Context, arg2 []string) (io.ReadCloser, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.imageSaveMutex.Lock()
	ret, specificReturn := fake.imageSaveReturnsOnCall[len(fake.imageSaveArgsForCall)]
	fake.imageSaveArgsForCall = append(fake.imageSaveArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	fake.recordInvocation("ImageSave", []interface{}{arg1, arg2Copy})
	fake.imageSaveMutex.Unlock()
	if fake.ImageSaveStub != nil {
		return fake.ImageSaveStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageSaveReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageSaveCallCount() int {
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	return len(fake.imageSaveArgsForCall)
}

func (fake *fakeDockerClient) ImageSaveCalls(stub func(context.Context, []string) (io.ReadCloser, error)) {
	fake.imageSaveMutex.Lock()
	defer fake.imageSaveMutex.Unlock()
	fake.ImageSaveStub = stub
}

func (fake *fakeDockerClient) ImageSaveArgsForCall(i int) (context.Context, []string) {
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	argsForCall := fake.imageSaveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ImageSaveReturns(result1 io.ReadCloser, result2 error) {
	fake.imageSaveMutex.Lock()
	defer fake.imageSaveMutex.Unlock()
	fake.ImageSaveStub = nil
	fake.imageSaveReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSaveReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.imageSaveMutex.Lock()
	defer fake.imageSaveMutex.Unlock()
	fake.ImageSaveStub = nil
	if fake.imageSaveReturnsOnCall == nil {
		fake.imageSaveReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageSaveReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSearch(arg1 context.Context, arg2 string, arg3 types.ImageSearchOptions) ([]registry.SearchResult, error) {
	fake.imageSearchMutex.Lock()
	ret, specificReturn := fake.imageSearchReturnsOnCall[len(fake.imageSearchArgsForCall)]
	fake.imageSearchArgsForCall = append(fake.imageSearchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ImageSearchOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImageSearch", []interface{}{arg1, arg2, arg3})
	fake.imageSearchMutex.Unlock()
	if fake.ImageSearchStub != nil {
		return fake.ImageSearchStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imageSearchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImageSearchCallCount() int {
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	return len(fake.imageSearchArgsForCall)
}

func (fake *fakeDockerClient) ImageSearchCalls(stub func(context.Context, string, types.ImageSearchOptions) ([]registry.SearchResult, error)) {
	fake.imageSearchMutex.Lock()
	defer fake.imageSearchMutex.Unlock()
	fake.ImageSearchStub = stub
}

func (fake *fakeDockerClient) ImageSearchArgsForCall(i int) (context.Context, string, types.ImageSearchOptions) {
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	argsForCall := fake.imageSearchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImageSearchReturns(result1 []registry.SearchResult, result2 error) {
	fake.imageSearchMutex.Lock()
	defer fake.imageSearchMutex.Unlock()
	fake.ImageSearchStub = nil
	fake.imageSearchReturns = struct {
		result1 []registry.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageSearchReturnsOnCall(i int, result1 []registry.SearchResult, result2 error) {
	fake.imageSearchMutex.Lock()
	defer fake.imageSearchMutex.Unlock()
	fake.ImageSearchStub = nil
	if fake.imageSearchReturnsOnCall == nil {
		fake.imageSearchReturnsOnCall = make(map[int]struct {
			result1 []registry.SearchResult
			result2 error
		})
	}
	fake.imageSearchReturnsOnCall[i] = struct {
		result1 []registry.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImageTag(arg1 context.Context, arg2 string, arg3 string) error {
	fake.imageTagMutex.Lock()
	ret, specificReturn := fake.imageTagReturnsOnCall[len(fake.imageTagArgsForCall)]
	fake.imageTagArgsForCall = append(fake.imageTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ImageTag", []interface{}{arg1, arg2, arg3})
	fake.imageTagMutex.Unlock()
	if fake.ImageTagStub != nil {
		return fake.ImageTagStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.imageTagReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ImageTagCallCount() int {
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	return len(fake.imageTagArgsForCall)
}

func (fake *fakeDockerClient) ImageTagCalls(stub func(context.Context, string, string) error) {
	fake.imageTagMutex.Lock()
	defer fake.imageTagMutex.Unlock()
	fake.ImageTagStub = stub
}

func (fake *fakeDockerClient) ImageTagArgsForCall(i int) (context.Context, string, string) {
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	argsForCall := fake.imageTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ImageTagReturns(result1 error) {
	fake.imageTagMutex.Lock()
	defer fake.imageTagMutex.Unlock()
	fake.ImageTagStub = nil
	fake.imageTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ImageTagReturnsOnCall(i int, result1 error) {
	fake.imageTagMutex.Lock()
	defer fake.imageTagMutex.Unlock()
	fake.ImageTagStub = nil
	if fake.imageTagReturnsOnCall == nil {
		fake.imageTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.imageTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ImagesPrune(arg1 context.Context, arg2 filters.Args) (types.ImagesPruneReport, error) {
	fake.imagesPruneMutex.Lock()
	ret, specificReturn := fake.imagesPruneReturnsOnCall[len(fake.imagesPruneArgsForCall)]
	fake.imagesPruneArgsForCall = append(fake.imagesPruneArgsForCall, struct {
		arg1 context.Context
		arg2 filters.Args
	}{arg1, arg2})
	fake.recordInvocation("ImagesPrune", []interface{}{arg1, arg2})
	fake.imagesPruneMutex.Unlock()
	if fake.ImagesPruneStub != nil {
		return fake.ImagesPruneStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.imagesPruneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ImagesPruneCallCount() int {
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	return len(fake.imagesPruneArgsForCall)
}

func (fake *fakeDockerClient) ImagesPruneCalls(stub func(context.Context, filters.Args) (types.ImagesPruneReport, error)) {
	fake.imagesPruneMutex.Lock()
	defer fake.imagesPruneMutex.Unlock()
	fake.ImagesPruneStub = stub
}

func (fake *fakeDockerClient) ImagesPruneArgsForCall(i int) (context.Context, filters.Args) {
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	argsForCall := fake.imagesPruneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ImagesPruneReturns(result1 types.ImagesPruneReport, result2 error) {
	fake.imagesPruneMutex.Lock()
	defer fake.imagesPruneMutex.Unlock()
	fake.ImagesPruneStub = nil
	fake.imagesPruneReturns = struct {
		result1 types.ImagesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ImagesPruneReturnsOnCall(i int, result1 types.ImagesPruneReport, result2 error) {
	fake.imagesPruneMutex.Lock()
	defer fake.imagesPruneMutex.Unlock()
	fake.ImagesPruneStub = nil
	if fake.imagesPruneReturnsOnCall == nil {
		fake.imagesPruneReturnsOnCall = make(map[int]struct {
			result1 types.ImagesPruneReport
			result2 error
		})
	}
	fake.imagesPruneReturnsOnCall[i] = struct {
		result1 types.ImagesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Info(arg1 context.Context) (types.Info, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Info", []interface{}{arg1})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.infoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *fakeDockerClient) InfoCalls(stub func(context.Context) (types.Info, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *fakeDockerClient) InfoArgsForCall(i int) context.Context {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) InfoReturns(result1 types.Info, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 types.Info
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) InfoReturnsOnCall(i int, result1 types.Info, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 types.Info
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 types.Info
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NegotiateAPIVersion(arg1 context.Context) {
	fake.negotiateAPIVersionMutex.Lock()
	fake.negotiateAPIVersionArgsForCall = append(fake.negotiateAPIVersionArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("NegotiateAPIVersion", []interface{}{arg1})
	fake.negotiateAPIVersionMutex.Unlock()
	if fake.NegotiateAPIVersionStub != nil {
		fake.NegotiateAPIVersionStub(arg1)
	}
}

func (fake *fakeDockerClient) NegotiateAPIVersionCallCount() int {
	fake.negotiateAPIVersionMutex.RLock()
	defer fake.negotiateAPIVersionMutex.RUnlock()
	return len(fake.negotiateAPIVersionArgsForCall)
}

func (fake *fakeDockerClient) NegotiateAPIVersionCalls(stub func(context.Context)) {
	fake.negotiateAPIVersionMutex.Lock()
	defer fake.negotiateAPIVersionMutex.Unlock()
	fake.NegotiateAPIVersionStub = stub
}

func (fake *fakeDockerClient) NegotiateAPIVersionArgsForCall(i int) context.Context {
	fake.negotiateAPIVersionMutex.RLock()
	defer fake.negotiateAPIVersionMutex.RUnlock()
	argsForCall := fake.negotiateAPIVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) NegotiateAPIVersionPing(arg1 types.Ping) {
	fake.negotiateAPIVersionPingMutex.Lock()
	fake.negotiateAPIVersionPingArgsForCall = append(fake.negotiateAPIVersionPingArgsForCall, struct {
		arg1 types.Ping
	}{arg1})
	fake.recordInvocation("NegotiateAPIVersionPing", []interface{}{arg1})
	fake.negotiateAPIVersionPingMutex.Unlock()
	if fake.NegotiateAPIVersionPingStub != nil {
		fake.NegotiateAPIVersionPingStub(arg1)
	}
}

func (fake *fakeDockerClient) NegotiateAPIVersionPingCallCount() int {
	fake.negotiateAPIVersionPingMutex.RLock()
	defer fake.negotiateAPIVersionPingMutex.RUnlock()
	return len(fake.negotiateAPIVersionPingArgsForCall)
}

func (fake *fakeDockerClient) NegotiateAPIVersionPingCalls(stub func(types.Ping)) {
	fake.negotiateAPIVersionPingMutex.Lock()
	defer fake.negotiateAPIVersionPingMutex.Unlock()
	fake.NegotiateAPIVersionPingStub = stub
}

func (fake *fakeDockerClient) NegotiateAPIVersionPingArgsForCall(i int) types.Ping {
	fake.negotiateAPIVersionPingMutex.RLock()
	defer fake.negotiateAPIVersionPingMutex.RUnlock()
	argsForCall := fake.negotiateAPIVersionPingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) NetworkConnect(arg1 context.Context, arg2 string, arg3 string, arg4 *network.EndpointSettings) error {
	fake.networkConnectMutex.Lock()
	ret, specificReturn := fake.networkConnectReturnsOnCall[len(fake.networkConnectArgsForCall)]
	fake.networkConnectArgsForCall = append(fake.networkConnectArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *network.EndpointSettings
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("NetworkConnect", []interface{}{arg1, arg2, arg3, arg4})
	fake.networkConnectMutex.Unlock()
	if fake.NetworkConnectStub != nil {
		return fake.NetworkConnectStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.networkConnectReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) NetworkConnectCallCount() int {
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	return len(fake.networkConnectArgsForCall)
}

func (fake *fakeDockerClient) NetworkConnectCalls(stub func(context.Context, string, string, *network.EndpointSettings) error) {
	fake.networkConnectMutex.Lock()
	defer fake.networkConnectMutex.Unlock()
	fake.NetworkConnectStub = stub
}

func (fake *fakeDockerClient) NetworkConnectArgsForCall(i int) (context.Context, string, string, *network.EndpointSettings) {
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	argsForCall := fake.networkConnectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) NetworkConnectReturns(result1 error) {
	fake.networkConnectMutex.Lock()
	defer fake.networkConnectMutex.Unlock()
	fake.NetworkConnectStub = nil
	fake.networkConnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkConnectReturnsOnCall(i int, result1 error) {
	fake.networkConnectMutex.Lock()
	defer fake.networkConnectMutex.Unlock()
	fake.NetworkConnectStub = nil
	if fake.networkConnectReturnsOnCall == nil {
		fake.networkConnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkConnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkCreate(arg1 context.Context, arg2 string, arg3 types.NetworkCreate) (types.NetworkCreateResponse, error) {
	fake.networkCreateMutex.Lock()
	ret, specificReturn := fake.networkCreateReturnsOnCall[len(fake.networkCreateArgsForCall)]
	fake.networkCreateArgsForCall = append(fake.networkCreateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.NetworkCreate
	}{arg1, arg2, arg3})
	fake.recordInvocation("NetworkCreate", []interface{}{arg1, arg2, arg3})
	fake.networkCreateMutex.Unlock()
	if fake.NetworkCreateStub != nil {
		return fake.NetworkCreateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.networkCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) NetworkCreateCallCount() int {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	return len(fake.networkCreateArgsForCall)
}

func (fake *fakeDockerClient) NetworkCreateCalls(stub func(context.Context, string, types.NetworkCreate) (types.NetworkCreateResponse, error)) {
	fake.networkCreateMutex.Lock()
	defer fake.networkCreateMutex.Unlock()
	fake.NetworkCreateStub = stub
}

func (fake *fakeDockerClient) NetworkCreateArgsForCall(i int) (context.Context, string, types.NetworkCreate) {
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	argsForCall := fake.networkCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) NetworkCreateReturns(result1 types.NetworkCreateResponse, result2 error) {
	fake.networkCreateMutex.Lock()
	defer fake.networkCreateMutex.Unlock()
	fake.NetworkCreateStub = nil
	fake.networkCreateReturns = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkCreateReturnsOnCall(i int, result1 types.NetworkCreateResponse, result2 error) {
	fake.networkCreateMutex.Lock()
	defer fake.networkCreateMutex.Unlock()
	fake.NetworkCreateStub = nil
	if fake.networkCreateReturnsOnCall == nil {
		fake.networkCreateReturnsOnCall = make(map[int]struct {
			result1 types.NetworkCreateResponse
			result2 error
		})
	}
	fake.networkCreateReturnsOnCall[i] = struct {
		result1 types.NetworkCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkDisconnect(arg1 context.Context, arg2 string, arg3 string, arg4 bool) error {
	fake.networkDisconnectMutex.Lock()
	ret, specificReturn := fake.networkDisconnectReturnsOnCall[len(fake.networkDisconnectArgsForCall)]
	fake.networkDisconnectArgsForCall = append(fake.networkDisconnectArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("NetworkDisconnect", []interface{}{arg1, arg2, arg3, arg4})
	fake.networkDisconnectMutex.Unlock()
	if fake.NetworkDisconnectStub != nil {
		return fake.NetworkDisconnectStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.networkDisconnectReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) NetworkDisconnectCallCount() int {
	fake.networkDisconnectMutex.RLock()
	defer fake.networkDisconnectMutex.RUnlock()
	return len(fake.networkDisconnectArgsForCall)
}

func (fake *fakeDockerClient) NetworkDisconnectCalls(stub func(context.Context, string, string, bool) error) {
	fake.networkDisconnectMutex.Lock()
	defer fake.networkDisconnectMutex.Unlock()
	fake.NetworkDisconnectStub = stub
}

func (fake *fakeDockerClient) NetworkDisconnectArgsForCall(i int) (context.Context, string, string, bool) {
	fake.networkDisconnectMutex.RLock()
	defer fake.networkDisconnectMutex.RUnlock()
	argsForCall := fake.networkDisconnectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) NetworkDisconnectReturns(result1 error) {
	fake.networkDisconnectMutex.Lock()
	defer fake.networkDisconnectMutex.Unlock()
	fake.NetworkDisconnectStub = nil
	fake.networkDisconnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkDisconnectReturnsOnCall(i int, result1 error) {
	fake.networkDisconnectMutex.Lock()
	defer fake.networkDisconnectMutex.Unlock()
	fake.NetworkDisconnectStub = nil
	if fake.networkDisconnectReturnsOnCall == nil {
		fake.networkDisconnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkDisconnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkInspect(arg1 context.Context, arg2 string, arg3 types.NetworkInspectOptions) (types.NetworkResource, error) {
	fake.networkInspectMutex.Lock()
	ret, specificReturn := fake.networkInspectReturnsOnCall[len(fake.networkInspectArgsForCall)]
	fake.networkInspectArgsForCall = append(fake.networkInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.NetworkInspectOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("NetworkInspect", []interface{}{arg1, arg2, arg3})
	fake.networkInspectMutex.Unlock()
	if fake.NetworkInspectStub != nil {
		return fake.NetworkInspectStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.networkInspectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) NetworkInspectCallCount() int {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	return len(fake.networkInspectArgsForCall)
}

func (fake *fakeDockerClient) NetworkInspectCalls(stub func(context.Context, string, types.NetworkInspectOptions) (types.NetworkResource, error)) {
	fake.networkInspectMutex.Lock()
	defer fake.networkInspectMutex.Unlock()
	fake.NetworkInspectStub = stub
}

func (fake *fakeDockerClient) NetworkInspectArgsForCall(i int) (context.Context, string, types.NetworkInspectOptions) {
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	argsForCall := fake.networkInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) NetworkInspectReturns(result1 types.NetworkResource, result2 error) {
	fake.networkInspectMutex.Lock()
	defer fake.networkInspectMutex.Unlock()
	fake.NetworkInspectStub = nil
	fake.networkInspectReturns = struct {
		result1 types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkInspectReturnsOnCall(i int, result1 types.NetworkResource, result2 error) {
	fake.networkInspectMutex.Lock()
	defer fake.networkInspectMutex.Unlock()
	fake.NetworkInspectStub = nil
	if fake.networkInspectReturnsOnCall == nil {
		fake.networkInspectReturnsOnCall = make(map[int]struct {
			result1 types.NetworkResource
			result2 error
		})
	}
	fake.networkInspectReturnsOnCall[i] = struct {
		result1 types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkInspectWithRaw(arg1 context.Context, arg2 string, arg3 types.NetworkInspectOptions) (types.NetworkResource, []byte, error) {
	fake.networkInspectWithRawMutex.Lock()
	ret, specificReturn := fake.networkInspectWithRawReturnsOnCall[len(fake.networkInspectWithRawArgsForCall)]
	fake.networkInspectWithRawArgsForCall = append(fake.networkInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.NetworkInspectOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("NetworkInspectWithRaw", []interface{}{arg1, arg2, arg3})
	fake.networkInspectWithRawMutex.Unlock()
	if fake.NetworkInspectWithRawStub != nil {
		return fake.NetworkInspectWithRawStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.networkInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) NetworkInspectWithRawCallCount() int {
	fake.networkInspectWithRawMutex.RLock()
	defer fake.networkInspectWithRawMutex.RUnlock()
	return len(fake.networkInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) NetworkInspectWithRawCalls(stub func(context.Context, string, types.NetworkInspectOptions) (types.NetworkResource, []byte, error)) {
	fake.networkInspectWithRawMutex.Lock()
	defer fake.networkInspectWithRawMutex.Unlock()
	fake.NetworkInspectWithRawStub = stub
}

func (fake *fakeDockerClient) NetworkInspectWithRawArgsForCall(i int) (context.Context, string, types.NetworkInspectOptions) {
	fake.networkInspectWithRawMutex.RLock()
	defer fake.networkInspectWithRawMutex.RUnlock()
	argsForCall := fake.networkInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) NetworkInspectWithRawReturns(result1 types.NetworkResource, result2 []byte, result3 error) {
	fake.networkInspectWithRawMutex.Lock()
	defer fake.networkInspectWithRawMutex.Unlock()
	fake.NetworkInspectWithRawStub = nil
	fake.networkInspectWithRawReturns = struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NetworkInspectWithRawReturnsOnCall(i int, result1 types.NetworkResource, result2 []byte, result3 error) {
	fake.networkInspectWithRawMutex.Lock()
	defer fake.networkInspectWithRawMutex.Unlock()
	fake.NetworkInspectWithRawStub = nil
	if fake.networkInspectWithRawReturnsOnCall == nil {
		fake.networkInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.NetworkResource
			result2 []byte
			result3 error
		})
	}
	fake.networkInspectWithRawReturnsOnCall[i] = struct {
		result1 types.NetworkResource
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NetworkList(arg1 context.Context, arg2 types.NetworkListOptions) ([]types.NetworkResource, error) {
	fake.networkListMutex.Lock()
	ret, specificReturn := fake.networkListReturnsOnCall[len(fake.networkListArgsForCall)]
	fake.networkListArgsForCall = append(fake.networkListArgsForCall, struct {
		arg1 context.Context
		arg2 types.NetworkListOptions
	}{arg1, arg2})
	fake.recordInvocation("NetworkList", []interface{}{arg1, arg2})
	fake.networkListMutex.Unlock()
	if fake.NetworkListStub != nil {
		return fake.NetworkListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.networkListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) NetworkListCallCount() int {
	fake.networkListMutex.RLock()
	defer fake.networkListMutex.RUnlock()
	return len(fake.networkListArgsForCall)
}

func (fake *fakeDockerClient) NetworkListCalls(stub func(context.Context, types.NetworkListOptions) ([]types.NetworkResource, error)) {
	fake.networkListMutex.Lock()
	defer fake.networkListMutex.Unlock()
	fake.NetworkListStub = stub
}

func (fake *fakeDockerClient) NetworkListArgsForCall(i int) (context.Context, types.NetworkListOptions) {
	fake.networkListMutex.RLock()
	defer fake.networkListMutex.RUnlock()
	argsForCall := fake.networkListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) NetworkListReturns(result1 []types.NetworkResource, result2 error) {
	fake.networkListMutex.Lock()
	defer fake.networkListMutex.Unlock()
	fake.NetworkListStub = nil
	fake.networkListReturns = struct {
		result1 []types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkListReturnsOnCall(i int, result1 []types.NetworkResource, result2 error) {
	fake.networkListMutex.Lock()
	defer fake.networkListMutex.Unlock()
	fake.NetworkListStub = nil
	if fake.networkListReturnsOnCall == nil {
		fake.networkListReturnsOnCall = make(map[int]struct {
			result1 []types.NetworkResource
			result2 error
		})
	}
	fake.networkListReturnsOnCall[i] = struct {
		result1 []types.NetworkResource
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworkRemove(arg1 context.Context, arg2 string) error {
	fake.networkRemoveMutex.Lock()
	ret, specificReturn := fake.networkRemoveReturnsOnCall[len(fake.networkRemoveArgsForCall)]
	fake.networkRemoveArgsForCall = append(fake.networkRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("NetworkRemove", []interface{}{arg1, arg2})
	fake.networkRemoveMutex.Unlock()
	if fake.NetworkRemoveStub != nil {
		return fake.NetworkRemoveStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.networkRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) NetworkRemoveCallCount() int {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	return len(fake.networkRemoveArgsForCall)
}

func (fake *fakeDockerClient) NetworkRemoveCalls(stub func(context.Context, string) error) {
	fake.networkRemoveMutex.Lock()
	defer fake.networkRemoveMutex.Unlock()
	fake.NetworkRemoveStub = stub
}

func (fake *fakeDockerClient) NetworkRemoveArgsForCall(i int) (context.Context, string) {
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	argsForCall := fake.networkRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) NetworkRemoveReturns(result1 error) {
	fake.networkRemoveMutex.Lock()
	defer fake.networkRemoveMutex.Unlock()
	fake.NetworkRemoveStub = nil
	fake.networkRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworkRemoveReturnsOnCall(i int, result1 error) {
	fake.networkRemoveMutex.Lock()
	defer fake.networkRemoveMutex.Unlock()
	fake.NetworkRemoveStub = nil
	if fake.networkRemoveReturnsOnCall == nil {
		fake.networkRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.networkRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NetworksPrune(arg1 context.Context, arg2 filters.Args) (types.NetworksPruneReport, error) {
	fake.networksPruneMutex.Lock()
	ret, specificReturn := fake.networksPruneReturnsOnCall[len(fake.networksPruneArgsForCall)]
	fake.networksPruneArgsForCall = append(fake.networksPruneArgsForCall, struct {
		arg1 context.Context
		arg2 filters.Args
	}{arg1, arg2})
	fake.recordInvocation("NetworksPrune", []interface{}{arg1, arg2})
	fake.networksPruneMutex.Unlock()
	if fake.NetworksPruneStub != nil {
		return fake.NetworksPruneStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.networksPruneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) NetworksPruneCallCount() int {
	fake.networksPruneMutex.RLock()
	defer fake.networksPruneMutex.RUnlock()
	return len(fake.networksPruneArgsForCall)
}

func (fake *fakeDockerClient) NetworksPruneCalls(stub func(context.Context, filters.Args) (types.NetworksPruneReport, error)) {
	fake.networksPruneMutex.Lock()
	defer fake.networksPruneMutex.Unlock()
	fake.NetworksPruneStub = stub
}

func (fake *fakeDockerClient) NetworksPruneArgsForCall(i int) (context.Context, filters.Args) {
	fake.networksPruneMutex.RLock()
	defer fake.networksPruneMutex.RUnlock()
	argsForCall := fake.networksPruneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) NetworksPruneReturns(result1 types.NetworksPruneReport, result2 error) {
	fake.networksPruneMutex.Lock()
	defer fake.networksPruneMutex.Unlock()
	fake.NetworksPruneStub = nil
	fake.networksPruneReturns = struct {
		result1 types.NetworksPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NetworksPruneReturnsOnCall(i int, result1 types.NetworksPruneReport, result2 error) {
	fake.networksPruneMutex.Lock()
	defer fake.networksPruneMutex.Unlock()
	fake.NetworksPruneStub = nil
	if fake.networksPruneReturnsOnCall == nil {
		fake.networksPruneReturnsOnCall = make(map[int]struct {
			result1 types.NetworksPruneReport
			result2 error
		})
	}
	fake.networksPruneReturnsOnCall[i] = struct {
		result1 types.NetworksPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NodeInspectWithRaw(arg1 context.Context, arg2 string) (swarm.Node, []byte, error) {
	fake.nodeInspectWithRawMutex.Lock()
	ret, specificReturn := fake.nodeInspectWithRawReturnsOnCall[len(fake.nodeInspectWithRawArgsForCall)]
	fake.nodeInspectWithRawArgsForCall = append(fake.nodeInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("NodeInspectWithRaw", []interface{}{arg1, arg2})
	fake.nodeInspectWithRawMutex.Unlock()
	if fake.NodeInspectWithRawStub != nil {
		return fake.NodeInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.nodeInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) NodeInspectWithRawCallCount() int {
	fake.nodeInspectWithRawMutex.RLock()
	defer fake.nodeInspectWithRawMutex.RUnlock()
	return len(fake.nodeInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) NodeInspectWithRawCalls(stub func(context.Context, string) (swarm.Node, []byte, error)) {
	fake.nodeInspectWithRawMutex.Lock()
	defer fake.nodeInspectWithRawMutex.Unlock()
	fake.NodeInspectWithRawStub = stub
}

func (fake *fakeDockerClient) NodeInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.nodeInspectWithRawMutex.RLock()
	defer fake.nodeInspectWithRawMutex.RUnlock()
	argsForCall := fake.nodeInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) NodeInspectWithRawReturns(result1 swarm.Node, result2 []byte, result3 error) {
	fake.nodeInspectWithRawMutex.Lock()
	defer fake.nodeInspectWithRawMutex.Unlock()
	fake.NodeInspectWithRawStub = nil
	fake.nodeInspectWithRawReturns = struct {
		result1 swarm.Node
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NodeInspectWithRawReturnsOnCall(i int, result1 swarm.Node, result2 []byte, result3 error) {
	fake.nodeInspectWithRawMutex.Lock()
	defer fake.nodeInspectWithRawMutex.Unlock()
	fake.NodeInspectWithRawStub = nil
	if fake.nodeInspectWithRawReturnsOnCall == nil {
		fake.nodeInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarm.Node
			result2 []byte
			result3 error
		})
	}
	fake.nodeInspectWithRawReturnsOnCall[i] = struct {
		result1 swarm.Node
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) NodeList(arg1 context.Context, arg2 types.NodeListOptions) ([]swarm.Node, error) {
	fake.nodeListMutex.Lock()
	ret, specificReturn := fake.nodeListReturnsOnCall[len(fake.nodeListArgsForCall)]
	fake.nodeListArgsForCall = append(fake.nodeListArgsForCall, struct {
		arg1 context.Context
		arg2 types.NodeListOptions
	}{arg1, arg2})
	fake.recordInvocation("NodeList", []interface{}{arg1, arg2})
	fake.nodeListMutex.Unlock()
	if fake.NodeListStub != nil {
		return fake.NodeListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.nodeListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) NodeListCallCount() int {
	fake.nodeListMutex.RLock()
	defer fake.nodeListMutex.RUnlock()
	return len(fake.nodeListArgsForCall)
}

func (fake *fakeDockerClient) NodeListCalls(stub func(context.Context, types.NodeListOptions) ([]swarm.Node, error)) {
	fake.nodeListMutex.Lock()
	defer fake.nodeListMutex.Unlock()
	fake.NodeListStub = stub
}

func (fake *fakeDockerClient) NodeListArgsForCall(i int) (context.Context, types.NodeListOptions) {
	fake.nodeListMutex.RLock()
	defer fake.nodeListMutex.RUnlock()
	argsForCall := fake.nodeListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) NodeListReturns(result1 []swarm.Node, result2 error) {
	fake.nodeListMutex.Lock()
	defer fake.nodeListMutex.Unlock()
	fake.NodeListStub = nil
	fake.nodeListReturns = struct {
		result1 []swarm.Node
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NodeListReturnsOnCall(i int, result1 []swarm.Node, result2 error) {
	fake.nodeListMutex.Lock()
	defer fake.nodeListMutex.Unlock()
	fake.NodeListStub = nil
	if fake.nodeListReturnsOnCall == nil {
		fake.nodeListReturnsOnCall = make(map[int]struct {
			result1 []swarm.Node
			result2 error
		})
	}
	fake.nodeListReturnsOnCall[i] = struct {
		result1 []swarm.Node
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) NodeRemove(arg1 context.Context, arg2 string, arg3 types.NodeRemoveOptions) error {
	fake.nodeRemoveMutex.Lock()
	ret, specificReturn := fake.nodeRemoveReturnsOnCall[len(fake.nodeRemoveArgsForCall)]
	fake.nodeRemoveArgsForCall = append(fake.nodeRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.NodeRemoveOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("NodeRemove", []interface{}{arg1, arg2, arg3})
	fake.nodeRemoveMutex.Unlock()
	if fake.NodeRemoveStub != nil {
		return fake.NodeRemoveStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodeRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) NodeRemoveCallCount() int {
	fake.nodeRemoveMutex.RLock()
	defer fake.nodeRemoveMutex.RUnlock()
	return len(fake.nodeRemoveArgsForCall)
}

func (fake *fakeDockerClient) NodeRemoveCalls(stub func(context.Context, string, types.NodeRemoveOptions) error) {
	fake.nodeRemoveMutex.Lock()
	defer fake.nodeRemoveMutex.Unlock()
	fake.NodeRemoveStub = stub
}

func (fake *fakeDockerClient) NodeRemoveArgsForCall(i int) (context.Context, string, types.NodeRemoveOptions) {
	fake.nodeRemoveMutex.RLock()
	defer fake.nodeRemoveMutex.RUnlock()
	argsForCall := fake.nodeRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) NodeRemoveReturns(result1 error) {
	fake.nodeRemoveMutex.Lock()
	defer fake.nodeRemoveMutex.Unlock()
	fake.NodeRemoveStub = nil
	fake.nodeRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NodeRemoveReturnsOnCall(i int, result1 error) {
	fake.nodeRemoveMutex.Lock()
	defer fake.nodeRemoveMutex.Unlock()
	fake.NodeRemoveStub = nil
	if fake.nodeRemoveReturnsOnCall == nil {
		fake.nodeRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nodeRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NodeUpdate(arg1 context.Context, arg2 string, arg3 swarm.Version, arg4 swarm.NodeSpec) error {
	fake.nodeUpdateMutex.Lock()
	ret, specificReturn := fake.nodeUpdateReturnsOnCall[len(fake.nodeUpdateArgsForCall)]
	fake.nodeUpdateArgsForCall = append(fake.nodeUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.NodeSpec
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("NodeUpdate", []interface{}{arg1, arg2, arg3, arg4})
	fake.nodeUpdateMutex.Unlock()
	if fake.NodeUpdateStub != nil {
		return fake.NodeUpdateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nodeUpdateReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) NodeUpdateCallCount() int {
	fake.nodeUpdateMutex.RLock()
	defer fake.nodeUpdateMutex.RUnlock()
	return len(fake.nodeUpdateArgsForCall)
}

func (fake *fakeDockerClient) NodeUpdateCalls(stub func(context.Context, string, swarm.Version, swarm.NodeSpec) error) {
	fake.nodeUpdateMutex.Lock()
	defer fake.nodeUpdateMutex.Unlock()
	fake.NodeUpdateStub = stub
}

func (fake *fakeDockerClient) NodeUpdateArgsForCall(i int) (context.Context, string, swarm.Version, swarm.NodeSpec) {
	fake.nodeUpdateMutex.RLock()
	defer fake.nodeUpdateMutex.RUnlock()
	argsForCall := fake.nodeUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) NodeUpdateReturns(result1 error) {
	fake.nodeUpdateMutex.Lock()
	defer fake.nodeUpdateMutex.Unlock()
	fake.NodeUpdateStub = nil
	fake.nodeUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) NodeUpdateReturnsOnCall(i int, result1 error) {
	fake.nodeUpdateMutex.Lock()
	defer fake.nodeUpdateMutex.Unlock()
	fake.NodeUpdateStub = nil
	if fake.nodeUpdateReturnsOnCall == nil {
		fake.nodeUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.nodeUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) Ping(arg1 context.Context) (types.Ping, error) {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Ping", []interface{}{arg1})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *fakeDockerClient) PingCalls(stub func(context.Context) (types.Ping, error)) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *fakeDockerClient) PingArgsForCall(i int) context.Context {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) PingReturns(result1 types.Ping, result2 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 types.Ping
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PingReturnsOnCall(i int, result1 types.Ping, result2 error) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 types.Ping
			result2 error
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 types.Ping
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginCreate(arg1 context.Context, arg2 io.Reader, arg3 types.PluginCreateOptions) error {
	fake.pluginCreateMutex.Lock()
	ret, specificReturn := fake.pluginCreateReturnsOnCall[len(fake.pluginCreateArgsForCall)]
	fake.pluginCreateArgsForCall = append(fake.pluginCreateArgsForCall, struct {
		arg1 context.Context
		arg2 io.Reader
		arg3 types.PluginCreateOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginCreate", []interface{}{arg1, arg2, arg3})
	fake.pluginCreateMutex.Unlock()
	if fake.PluginCreateStub != nil {
		return fake.PluginCreateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginCreateReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) PluginCreateCallCount() int {
	fake.pluginCreateMutex.RLock()
	defer fake.pluginCreateMutex.RUnlock()
	return len(fake.pluginCreateArgsForCall)
}

func (fake *fakeDockerClient) PluginCreateCalls(stub func(context.Context, io.Reader, types.PluginCreateOptions) error) {
	fake.pluginCreateMutex.Lock()
	defer fake.pluginCreateMutex.Unlock()
	fake.PluginCreateStub = stub
}

func (fake *fakeDockerClient) PluginCreateArgsForCall(i int) (context.Context, io.Reader, types.PluginCreateOptions) {
	fake.pluginCreateMutex.RLock()
	defer fake.pluginCreateMutex.RUnlock()
	argsForCall := fake.pluginCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginCreateReturns(result1 error) {
	fake.pluginCreateMutex.Lock()
	defer fake.pluginCreateMutex.Unlock()
	fake.PluginCreateStub = nil
	fake.pluginCreateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginCreateReturnsOnCall(i int, result1 error) {
	fake.pluginCreateMutex.Lock()
	defer fake.pluginCreateMutex.Unlock()
	fake.PluginCreateStub = nil
	if fake.pluginCreateReturnsOnCall == nil {
		fake.pluginCreateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginCreateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginDisable(arg1 context.Context, arg2 string, arg3 types.PluginDisableOptions) error {
	fake.pluginDisableMutex.Lock()
	ret, specificReturn := fake.pluginDisableReturnsOnCall[len(fake.pluginDisableArgsForCall)]
	fake.pluginDisableArgsForCall = append(fake.pluginDisableArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginDisableOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginDisable", []interface{}{arg1, arg2, arg3})
	fake.pluginDisableMutex.Unlock()
	if fake.PluginDisableStub != nil {
		return fake.PluginDisableStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginDisableReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) PluginDisableCallCount() int {
	fake.pluginDisableMutex.RLock()
	defer fake.pluginDisableMutex.RUnlock()
	return len(fake.pluginDisableArgsForCall)
}

func (fake *fakeDockerClient) PluginDisableCalls(stub func(context.Context, string, types.PluginDisableOptions) error) {
	fake.pluginDisableMutex.Lock()
	defer fake.pluginDisableMutex.Unlock()
	fake.PluginDisableStub = stub
}

func (fake *fakeDockerClient) PluginDisableArgsForCall(i int) (context.Context, string, types.PluginDisableOptions) {
	fake.pluginDisableMutex.RLock()
	defer fake.pluginDisableMutex.RUnlock()
	argsForCall := fake.pluginDisableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginDisableReturns(result1 error) {
	fake.pluginDisableMutex.Lock()
	defer fake.pluginDisableMutex.Unlock()
	fake.PluginDisableStub = nil
	fake.pluginDisableReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginDisableReturnsOnCall(i int, result1 error) {
	fake.pluginDisableMutex.Lock()
	defer fake.pluginDisableMutex.Unlock()
	fake.PluginDisableStub = nil
	if fake.pluginDisableReturnsOnCall == nil {
		fake.pluginDisableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginDisableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginEnable(arg1 context.Context, arg2 string, arg3 types.PluginEnableOptions) error {
	fake.pluginEnableMutex.Lock()
	ret, specificReturn := fake.pluginEnableReturnsOnCall[len(fake.pluginEnableArgsForCall)]
	fake.pluginEnableArgsForCall = append(fake.pluginEnableArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginEnableOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginEnable", []interface{}{arg1, arg2, arg3})
	fake.pluginEnableMutex.Unlock()
	if fake.PluginEnableStub != nil {
		return fake.PluginEnableStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginEnableReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) PluginEnableCallCount() int {
	fake.pluginEnableMutex.RLock()
	defer fake.pluginEnableMutex.RUnlock()
	return len(fake.pluginEnableArgsForCall)
}

func (fake *fakeDockerClient) PluginEnableCalls(stub func(context.Context, string, types.PluginEnableOptions) error) {
	fake.pluginEnableMutex.Lock()
	defer fake.pluginEnableMutex.Unlock()
	fake.PluginEnableStub = stub
}

func (fake *fakeDockerClient) PluginEnableArgsForCall(i int) (context.Context, string, types.PluginEnableOptions) {
	fake.pluginEnableMutex.RLock()
	defer fake.pluginEnableMutex.RUnlock()
	argsForCall := fake.pluginEnableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginEnableReturns(result1 error) {
	fake.pluginEnableMutex.Lock()
	defer fake.pluginEnableMutex.Unlock()
	fake.PluginEnableStub = nil
	fake.pluginEnableReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginEnableReturnsOnCall(i int, result1 error) {
	fake.pluginEnableMutex.Lock()
	defer fake.pluginEnableMutex.Unlock()
	fake.PluginEnableStub = nil
	if fake.pluginEnableReturnsOnCall == nil {
		fake.pluginEnableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginEnableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginInspectWithRaw(arg1 context.Context, arg2 string) (*types.Plugin, []byte, error) {
	fake.pluginInspectWithRawMutex.Lock()
	ret, specificReturn := fake.pluginInspectWithRawReturnsOnCall[len(fake.pluginInspectWithRawArgsForCall)]
	fake.pluginInspectWithRawArgsForCall = append(fake.pluginInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("PluginInspectWithRaw", []interface{}{arg1, arg2})
	fake.pluginInspectWithRawMutex.Unlock()
	if fake.PluginInspectWithRawStub != nil {
		return fake.PluginInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.pluginInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) PluginInspectWithRawCallCount() int {
	fake.pluginInspectWithRawMutex.RLock()
	defer fake.pluginInspectWithRawMutex.RUnlock()
	return len(fake.pluginInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) PluginInspectWithRawCalls(stub func(context.Context, string) (*types.Plugin, []byte, error)) {
	fake.pluginInspectWithRawMutex.Lock()
	defer fake.pluginInspectWithRawMutex.Unlock()
	fake.PluginInspectWithRawStub = stub
}

func (fake *fakeDockerClient) PluginInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.pluginInspectWithRawMutex.RLock()
	defer fake.pluginInspectWithRawMutex.RUnlock()
	argsForCall := fake.pluginInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) PluginInspectWithRawReturns(result1 *types.Plugin, result2 []byte, result3 error) {
	fake.pluginInspectWithRawMutex.Lock()
	defer fake.pluginInspectWithRawMutex.Unlock()
	fake.PluginInspectWithRawStub = nil
	fake.pluginInspectWithRawReturns = struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) PluginInspectWithRawReturnsOnCall(i int, result1 *types.Plugin, result2 []byte, result3 error) {
	fake.pluginInspectWithRawMutex.Lock()
	defer fake.pluginInspectWithRawMutex.Unlock()
	fake.PluginInspectWithRawStub = nil
	if fake.pluginInspectWithRawReturnsOnCall == nil {
		fake.pluginInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 *types.Plugin
			result2 []byte
			result3 error
		})
	}
	fake.pluginInspectWithRawReturnsOnCall[i] = struct {
		result1 *types.Plugin
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) PluginInstall(arg1 context.Context, arg2 string, arg3 types.PluginInstallOptions) (io.ReadCloser, error) {
	fake.pluginInstallMutex.Lock()
	ret, specificReturn := fake.pluginInstallReturnsOnCall[len(fake.pluginInstallArgsForCall)]
	fake.pluginInstallArgsForCall = append(fake.pluginInstallArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginInstallOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginInstall", []interface{}{arg1, arg2, arg3})
	fake.pluginInstallMutex.Unlock()
	if fake.PluginInstallStub != nil {
		return fake.PluginInstallStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pluginInstallReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) PluginInstallCallCount() int {
	fake.pluginInstallMutex.RLock()
	defer fake.pluginInstallMutex.RUnlock()
	return len(fake.pluginInstallArgsForCall)
}

func (fake *fakeDockerClient) PluginInstallCalls(stub func(context.Context, string, types.PluginInstallOptions) (io.ReadCloser, error)) {
	fake.pluginInstallMutex.Lock()
	defer fake.pluginInstallMutex.Unlock()
	fake.PluginInstallStub = stub
}

func (fake *fakeDockerClient) PluginInstallArgsForCall(i int) (context.Context, string, types.PluginInstallOptions) {
	fake.pluginInstallMutex.RLock()
	defer fake.pluginInstallMutex.RUnlock()
	argsForCall := fake.pluginInstallArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginInstallReturns(result1 io.ReadCloser, result2 error) {
	fake.pluginInstallMutex.Lock()
	defer fake.pluginInstallMutex.Unlock()
	fake.PluginInstallStub = nil
	fake.pluginInstallReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginInstallReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.pluginInstallMutex.Lock()
	defer fake.pluginInstallMutex.Unlock()
	fake.PluginInstallStub = nil
	if fake.pluginInstallReturnsOnCall == nil {
		fake.pluginInstallReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.pluginInstallReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginList(arg1 context.Context, arg2 filters.Args) (types.PluginsListResponse, error) {
	fake.pluginListMutex.Lock()
	ret, specificReturn := fake.pluginListReturnsOnCall[len(fake.pluginListArgsForCall)]
	fake.pluginListArgsForCall = append(fake.pluginListArgsForCall, struct {
		arg1 context.Context
		arg2 filters.Args
	}{arg1, arg2})
	fake.recordInvocation("PluginList", []interface{}{arg1, arg2})
	fake.pluginListMutex.Unlock()
	if fake.PluginListStub != nil {
		return fake.PluginListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pluginListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) PluginListCallCount() int {
	fake.pluginListMutex.RLock()
	defer fake.pluginListMutex.RUnlock()
	return len(fake.pluginListArgsForCall)
}

func (fake *fakeDockerClient) PluginListCalls(stub func(context.Context, filters.Args) (types.PluginsListResponse, error)) {
	fake.pluginListMutex.Lock()
	defer fake.pluginListMutex.Unlock()
	fake.PluginListStub = stub
}

func (fake *fakeDockerClient) PluginListArgsForCall(i int) (context.Context, filters.Args) {
	fake.pluginListMutex.RLock()
	defer fake.pluginListMutex.RUnlock()
	argsForCall := fake.pluginListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) PluginListReturns(result1 types.PluginsListResponse, result2 error) {
	fake.pluginListMutex.Lock()
	defer fake.pluginListMutex.Unlock()
	fake.PluginListStub = nil
	fake.pluginListReturns = struct {
		result1 types.PluginsListResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginListReturnsOnCall(i int, result1 types.PluginsListResponse, result2 error) {
	fake.pluginListMutex.Lock()
	defer fake.pluginListMutex.Unlock()
	fake.PluginListStub = nil
	if fake.pluginListReturnsOnCall == nil {
		fake.pluginListReturnsOnCall = make(map[int]struct {
			result1 types.PluginsListResponse
			result2 error
		})
	}
	fake.pluginListReturnsOnCall[i] = struct {
		result1 types.PluginsListResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginPush(arg1 context.Context, arg2 string, arg3 string) (io.ReadCloser, error) {
	fake.pluginPushMutex.Lock()
	ret, specificReturn := fake.pluginPushReturnsOnCall[len(fake.pluginPushArgsForCall)]
	fake.pluginPushArgsForCall = append(fake.pluginPushArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginPush", []interface{}{arg1, arg2, arg3})
	fake.pluginPushMutex.Unlock()
	if fake.PluginPushStub != nil {
		return fake.PluginPushStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pluginPushReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) PluginPushCallCount() int {
	fake.pluginPushMutex.RLock()
	defer fake.pluginPushMutex.RUnlock()
	return len(fake.pluginPushArgsForCall)
}

func (fake *fakeDockerClient) PluginPushCalls(stub func(context.Context, string, string) (io.ReadCloser, error)) {
	fake.pluginPushMutex.Lock()
	defer fake.pluginPushMutex.Unlock()
	fake.PluginPushStub = stub
}

func (fake *fakeDockerClient) PluginPushArgsForCall(i int) (context.Context, string, string) {
	fake.pluginPushMutex.RLock()
	defer fake.pluginPushMutex.RUnlock()
	argsForCall := fake.pluginPushArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginPushReturns(result1 io.ReadCloser, result2 error) {
	fake.pluginPushMutex.Lock()
	defer fake.pluginPushMutex.Unlock()
	fake.PluginPushStub = nil
	fake.pluginPushReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginPushReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.pluginPushMutex.Lock()
	defer fake.pluginPushMutex.Unlock()
	fake.PluginPushStub = nil
	if fake.pluginPushReturnsOnCall == nil {
		fake.pluginPushReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.pluginPushReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginRemove(arg1 context.Context, arg2 string, arg3 types.PluginRemoveOptions) error {
	fake.pluginRemoveMutex.Lock()
	ret, specificReturn := fake.pluginRemoveReturnsOnCall[len(fake.pluginRemoveArgsForCall)]
	fake.pluginRemoveArgsForCall = append(fake.pluginRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginRemoveOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginRemove", []interface{}{arg1, arg2, arg3})
	fake.pluginRemoveMutex.Unlock()
	if fake.PluginRemoveStub != nil {
		return fake.PluginRemoveStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) PluginRemoveCallCount() int {
	fake.pluginRemoveMutex.RLock()
	defer fake.pluginRemoveMutex.RUnlock()
	return len(fake.pluginRemoveArgsForCall)
}

func (fake *fakeDockerClient) PluginRemoveCalls(stub func(context.Context, string, types.PluginRemoveOptions) error) {
	fake.pluginRemoveMutex.Lock()
	defer fake.pluginRemoveMutex.Unlock()
	fake.PluginRemoveStub = stub
}

func (fake *fakeDockerClient) PluginRemoveArgsForCall(i int) (context.Context, string, types.PluginRemoveOptions) {
	fake.pluginRemoveMutex.RLock()
	defer fake.pluginRemoveMutex.RUnlock()
	argsForCall := fake.pluginRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginRemoveReturns(result1 error) {
	fake.pluginRemoveMutex.Lock()
	defer fake.pluginRemoveMutex.Unlock()
	fake.PluginRemoveStub = nil
	fake.pluginRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginRemoveReturnsOnCall(i int, result1 error) {
	fake.pluginRemoveMutex.Lock()
	defer fake.pluginRemoveMutex.Unlock()
	fake.PluginRemoveStub = nil
	if fake.pluginRemoveReturnsOnCall == nil {
		fake.pluginRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginSet(arg1 context.Context, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.pluginSetMutex.Lock()
	ret, specificReturn := fake.pluginSetReturnsOnCall[len(fake.pluginSetArgsForCall)]
	fake.pluginSetArgsForCall = append(fake.pluginSetArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("PluginSet", []interface{}{arg1, arg2, arg3Copy})
	fake.pluginSetMutex.Unlock()
	if fake.PluginSetStub != nil {
		return fake.PluginSetStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginSetReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) PluginSetCallCount() int {
	fake.pluginSetMutex.RLock()
	defer fake.pluginSetMutex.RUnlock()
	return len(fake.pluginSetArgsForCall)
}

func (fake *fakeDockerClient) PluginSetCalls(stub func(context.Context, string, []string) error) {
	fake.pluginSetMutex.Lock()
	defer fake.pluginSetMutex.Unlock()
	fake.PluginSetStub = stub
}

func (fake *fakeDockerClient) PluginSetArgsForCall(i int) (context.Context, string, []string) {
	fake.pluginSetMutex.RLock()
	defer fake.pluginSetMutex.RUnlock()
	argsForCall := fake.pluginSetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginSetReturns(result1 error) {
	fake.pluginSetMutex.Lock()
	defer fake.pluginSetMutex.Unlock()
	fake.PluginSetStub = nil
	fake.pluginSetReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginSetReturnsOnCall(i int, result1 error) {
	fake.pluginSetMutex.Lock()
	defer fake.pluginSetMutex.Unlock()
	fake.PluginSetStub = nil
	if fake.pluginSetReturnsOnCall == nil {
		fake.pluginSetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pluginSetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) PluginUpgrade(arg1 context.Context, arg2 string, arg3 types.PluginInstallOptions) (io.ReadCloser, error) {
	fake.pluginUpgradeMutex.Lock()
	ret, specificReturn := fake.pluginUpgradeReturnsOnCall[len(fake.pluginUpgradeArgsForCall)]
	fake.pluginUpgradeArgsForCall = append(fake.pluginUpgradeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.PluginInstallOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("PluginUpgrade", []interface{}{arg1, arg2, arg3})
	fake.pluginUpgradeMutex.Unlock()
	if fake.PluginUpgradeStub != nil {
		return fake.PluginUpgradeStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pluginUpgradeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) PluginUpgradeCallCount() int {
	fake.pluginUpgradeMutex.RLock()
	defer fake.pluginUpgradeMutex.RUnlock()
	return len(fake.pluginUpgradeArgsForCall)
}

func (fake *fakeDockerClient) PluginUpgradeCalls(stub func(context.Context, string, types.PluginInstallOptions) (io.ReadCloser, error)) {
	fake.pluginUpgradeMutex.Lock()
	defer fake.pluginUpgradeMutex.Unlock()
	fake.PluginUpgradeStub = stub
}

func (fake *fakeDockerClient) PluginUpgradeArgsForCall(i int) (context.Context, string, types.PluginInstallOptions) {
	fake.pluginUpgradeMutex.RLock()
	defer fake.pluginUpgradeMutex.RUnlock()
	argsForCall := fake.pluginUpgradeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) PluginUpgradeReturns(result1 io.ReadCloser, result2 error) {
	fake.pluginUpgradeMutex.Lock()
	defer fake.pluginUpgradeMutex.Unlock()
	fake.PluginUpgradeStub = nil
	fake.pluginUpgradeReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) PluginUpgradeReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.pluginUpgradeMutex.Lock()
	defer fake.pluginUpgradeMutex.Unlock()
	fake.PluginUpgradeStub = nil
	if fake.pluginUpgradeReturnsOnCall == nil {
		fake.pluginUpgradeReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.pluginUpgradeReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) RegistryLogin(arg1 context.Context, arg2 types.AuthConfig) (registry.AuthenticateOKBody, error) {
	fake.registryLoginMutex.Lock()
	ret, specificReturn := fake.registryLoginReturnsOnCall[len(fake.registryLoginArgsForCall)]
	fake.registryLoginArgsForCall = append(fake.registryLoginArgsForCall, struct {
		arg1 context.Context
		arg2 types.AuthConfig
	}{arg1, arg2})
	fake.recordInvocation("RegistryLogin", []interface{}{arg1, arg2})
	fake.registryLoginMutex.Unlock()
	if fake.RegistryLoginStub != nil {
		return fake.RegistryLoginStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registryLoginReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) RegistryLoginCallCount() int {
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	return len(fake.registryLoginArgsForCall)
}

func (fake *fakeDockerClient) RegistryLoginCalls(stub func(context.Context, types.AuthConfig) (registry.AuthenticateOKBody, error)) {
	fake.registryLoginMutex.Lock()
	defer fake.registryLoginMutex.Unlock()
	fake.RegistryLoginStub = stub
}

func (fake *fakeDockerClient) RegistryLoginArgsForCall(i int) (context.Context, types.AuthConfig) {
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	argsForCall := fake.registryLoginArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) RegistryLoginReturns(result1 registry.AuthenticateOKBody, result2 error) {
	fake.registryLoginMutex.Lock()
	defer fake.registryLoginMutex.Unlock()
	fake.RegistryLoginStub = nil
	fake.registryLoginReturns = struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) RegistryLoginReturnsOnCall(i int, result1 registry.AuthenticateOKBody, result2 error) {
	fake.registryLoginMutex.Lock()
	defer fake.registryLoginMutex.Unlock()
	fake.RegistryLoginStub = nil
	if fake.registryLoginReturnsOnCall == nil {
		fake.registryLoginReturnsOnCall = make(map[int]struct {
			result1 registry.AuthenticateOKBody
			result2 error
		})
	}
	fake.registryLoginReturnsOnCall[i] = struct {
		result1 registry.AuthenticateOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretCreate(arg1 context.Context, arg2 swarm.SecretSpec) (types.SecretCreateResponse, error) {
	fake.secretCreateMutex.Lock()
	ret, specificReturn := fake.secretCreateReturnsOnCall[len(fake.secretCreateArgsForCall)]
	fake.secretCreateArgsForCall = append(fake.secretCreateArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.SecretSpec
	}{arg1, arg2})
	fake.recordInvocation("SecretCreate", []interface{}{arg1, arg2})
	fake.secretCreateMutex.Unlock()
	if fake.SecretCreateStub != nil {
		return fake.SecretCreateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.secretCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) SecretCreateCallCount() int {
	fake.secretCreateMutex.RLock()
	defer fake.secretCreateMutex.RUnlock()
	return len(fake.secretCreateArgsForCall)
}

func (fake *fakeDockerClient) SecretCreateCalls(stub func(context.Context, swarm.SecretSpec) (types.SecretCreateResponse, error)) {
	fake.secretCreateMutex.Lock()
	defer fake.secretCreateMutex.Unlock()
	fake.SecretCreateStub = stub
}

func (fake *fakeDockerClient) SecretCreateArgsForCall(i int) (context.Context, swarm.SecretSpec) {
	fake.secretCreateMutex.RLock()
	defer fake.secretCreateMutex.RUnlock()
	argsForCall := fake.secretCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SecretCreateReturns(result1 types.SecretCreateResponse, result2 error) {
	fake.secretCreateMutex.Lock()
	defer fake.secretCreateMutex.Unlock()
	fake.SecretCreateStub = nil
	fake.secretCreateReturns = struct {
		result1 types.SecretCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretCreateReturnsOnCall(i int, result1 types.SecretCreateResponse, result2 error) {
	fake.secretCreateMutex.Lock()
	defer fake.secretCreateMutex.Unlock()
	fake.SecretCreateStub = nil
	if fake.secretCreateReturnsOnCall == nil {
		fake.secretCreateReturnsOnCall = make(map[int]struct {
			result1 types.SecretCreateResponse
			result2 error
		})
	}
	fake.secretCreateReturnsOnCall[i] = struct {
		result1 types.SecretCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretInspectWithRaw(arg1 context.Context, arg2 string) (swarm.Secret, []byte, error) {
	fake.secretInspectWithRawMutex.Lock()
	ret, specificReturn := fake.secretInspectWithRawReturnsOnCall[len(fake.secretInspectWithRawArgsForCall)]
	fake.secretInspectWithRawArgsForCall = append(fake.secretInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SecretInspectWithRaw", []interface{}{arg1, arg2})
	fake.secretInspectWithRawMutex.Unlock()
	if fake.SecretInspectWithRawStub != nil {
		return fake.SecretInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.secretInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) SecretInspectWithRawCallCount() int {
	fake.secretInspectWithRawMutex.RLock()
	defer fake.secretInspectWithRawMutex.RUnlock()
	return len(fake.secretInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) SecretInspectWithRawCalls(stub func(context.Context, string) (swarm.Secret, []byte, error)) {
	fake.secretInspectWithRawMutex.Lock()
	defer fake.secretInspectWithRawMutex.Unlock()
	fake.SecretInspectWithRawStub = stub
}

func (fake *fakeDockerClient) SecretInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.secretInspectWithRawMutex.RLock()
	defer fake.secretInspectWithRawMutex.RUnlock()
	argsForCall := fake.secretInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SecretInspectWithRawReturns(result1 swarm.Secret, result2 []byte, result3 error) {
	fake.secretInspectWithRawMutex.Lock()
	defer fake.secretInspectWithRawMutex.Unlock()
	fake.SecretInspectWithRawStub = nil
	fake.secretInspectWithRawReturns = struct {
		result1 swarm.Secret
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) SecretInspectWithRawReturnsOnCall(i int, result1 swarm.Secret, result2 []byte, result3 error) {
	fake.secretInspectWithRawMutex.Lock()
	defer fake.secretInspectWithRawMutex.Unlock()
	fake.SecretInspectWithRawStub = nil
	if fake.secretInspectWithRawReturnsOnCall == nil {
		fake.secretInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarm.Secret
			result2 []byte
			result3 error
		})
	}
	fake.secretInspectWithRawReturnsOnCall[i] = struct {
		result1 swarm.Secret
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) SecretList(arg1 context.Context, arg2 types.SecretListOptions) ([]swarm.Secret, error) {
	fake.secretListMutex.Lock()
	ret, specificReturn := fake.secretListReturnsOnCall[len(fake.secretListArgsForCall)]
	fake.secretListArgsForCall = append(fake.secretListArgsForCall, struct {
		arg1 context.Context
		arg2 types.SecretListOptions
	}{arg1, arg2})
	fake.recordInvocation("SecretList", []interface{}{arg1, arg2})
	fake.secretListMutex.Unlock()
	if fake.SecretListStub != nil {
		return fake.SecretListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.secretListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) SecretListCallCount() int {
	fake.secretListMutex.RLock()
	defer fake.secretListMutex.RUnlock()
	return len(fake.secretListArgsForCall)
}

func (fake *fakeDockerClient) SecretListCalls(stub func(context.Context, types.SecretListOptions) ([]swarm.Secret, error)) {
	fake.secretListMutex.Lock()
	defer fake.secretListMutex.Unlock()
	fake.SecretListStub = stub
}

func (fake *fakeDockerClient) SecretListArgsForCall(i int) (context.Context, types.SecretListOptions) {
	fake.secretListMutex.RLock()
	defer fake.secretListMutex.RUnlock()
	argsForCall := fake.secretListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SecretListReturns(result1 []swarm.Secret, result2 error) {
	fake.secretListMutex.Lock()
	defer fake.secretListMutex.Unlock()
	fake.SecretListStub = nil
	fake.secretListReturns = struct {
		result1 []swarm.Secret
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretListReturnsOnCall(i int, result1 []swarm.Secret, result2 error) {
	fake.secretListMutex.Lock()
	defer fake.secretListMutex.Unlock()
	fake.SecretListStub = nil
	if fake.secretListReturnsOnCall == nil {
		fake.secretListReturnsOnCall = make(map[int]struct {
			result1 []swarm.Secret
			result2 error
		})
	}
	fake.secretListReturnsOnCall[i] = struct {
		result1 []swarm.Secret
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SecretRemove(arg1 context.Context, arg2 string) error {
	fake.secretRemoveMutex.Lock()
	ret, specificReturn := fake.secretRemoveReturnsOnCall[len(fake.secretRemoveArgsForCall)]
	fake.secretRemoveArgsForCall = append(fake.secretRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SecretRemove", []interface{}{arg1, arg2})
	fake.secretRemoveMutex.Unlock()
	if fake.SecretRemoveStub != nil {
		return fake.SecretRemoveStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.secretRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) SecretRemoveCallCount() int {
	fake.secretRemoveMutex.RLock()
	defer fake.secretRemoveMutex.RUnlock()
	return len(fake.secretRemoveArgsForCall)
}

func (fake *fakeDockerClient) SecretRemoveCalls(stub func(context.Context, string) error) {
	fake.secretRemoveMutex.Lock()
	defer fake.secretRemoveMutex.Unlock()
	fake.SecretRemoveStub = stub
}

func (fake *fakeDockerClient) SecretRemoveArgsForCall(i int) (context.Context, string) {
	fake.secretRemoveMutex.RLock()
	defer fake.secretRemoveMutex.RUnlock()
	argsForCall := fake.secretRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SecretRemoveReturns(result1 error) {
	fake.secretRemoveMutex.Lock()
	defer fake.secretRemoveMutex.Unlock()
	fake.SecretRemoveStub = nil
	fake.secretRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretRemoveReturnsOnCall(i int, result1 error) {
	fake.secretRemoveMutex.Lock()
	defer fake.secretRemoveMutex.Unlock()
	fake.SecretRemoveStub = nil
	if fake.secretRemoveReturnsOnCall == nil {
		fake.secretRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.secretRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretUpdate(arg1 context.Context, arg2 string, arg3 swarm.Version, arg4 swarm.SecretSpec) error {
	fake.secretUpdateMutex.Lock()
	ret, specificReturn := fake.secretUpdateReturnsOnCall[len(fake.secretUpdateArgsForCall)]
	fake.secretUpdateArgsForCall = append(fake.secretUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.SecretSpec
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SecretUpdate", []interface{}{arg1, arg2, arg3, arg4})
	fake.secretUpdateMutex.Unlock()
	if fake.SecretUpdateStub != nil {
		return fake.SecretUpdateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.secretUpdateReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) SecretUpdateCallCount() int {
	fake.secretUpdateMutex.RLock()
	defer fake.secretUpdateMutex.RUnlock()
	return len(fake.secretUpdateArgsForCall)
}

func (fake *fakeDockerClient) SecretUpdateCalls(stub func(context.Context, string, swarm.Version, swarm.SecretSpec) error) {
	fake.secretUpdateMutex.Lock()
	defer fake.secretUpdateMutex.Unlock()
	fake.SecretUpdateStub = stub
}

func (fake *fakeDockerClient) SecretUpdateArgsForCall(i int) (context.Context, string, swarm.Version, swarm.SecretSpec) {
	fake.secretUpdateMutex.RLock()
	defer fake.secretUpdateMutex.RUnlock()
	argsForCall := fake.secretUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) SecretUpdateReturns(result1 error) {
	fake.secretUpdateMutex.Lock()
	defer fake.secretUpdateMutex.Unlock()
	fake.SecretUpdateStub = nil
	fake.secretUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SecretUpdateReturnsOnCall(i int, result1 error) {
	fake.secretUpdateMutex.Lock()
	defer fake.secretUpdateMutex.Unlock()
	fake.SecretUpdateStub = nil
	if fake.secretUpdateReturnsOnCall == nil {
		fake.secretUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.secretUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ServerVersion(arg1 context.Context) (types.Version, error) {
	fake.serverVersionMutex.Lock()
	ret, specificReturn := fake.serverVersionReturnsOnCall[len(fake.serverVersionArgsForCall)]
	fake.serverVersionArgsForCall = append(fake.serverVersionArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ServerVersion", []interface{}{arg1})
	fake.serverVersionMutex.Unlock()
	if fake.ServerVersionStub != nil {
		return fake.ServerVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.serverVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ServerVersionCallCount() int {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	return len(fake.serverVersionArgsForCall)
}

func (fake *fakeDockerClient) ServerVersionCalls(stub func(context.Context) (types.Version, error)) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = stub
}

func (fake *fakeDockerClient) ServerVersionArgsForCall(i int) context.Context {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	argsForCall := fake.serverVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) ServerVersionReturns(result1 types.Version, result2 error) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = nil
	fake.serverVersionReturns = struct {
		result1 types.Version
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServerVersionReturnsOnCall(i int, result1 types.Version, result2 error) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = nil
	if fake.serverVersionReturnsOnCall == nil {
		fake.serverVersionReturnsOnCall = make(map[int]struct {
			result1 types.Version
			result2 error
		})
	}
	fake.serverVersionReturnsOnCall[i] = struct {
		result1 types.Version
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceCreate(arg1 context.Context, arg2 swarm.ServiceSpec, arg3 types.ServiceCreateOptions) (types.ServiceCreateResponse, error) {
	fake.serviceCreateMutex.Lock()
	ret, specificReturn := fake.serviceCreateReturnsOnCall[len(fake.serviceCreateArgsForCall)]
	fake.serviceCreateArgsForCall = append(fake.serviceCreateArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.ServiceSpec
		arg3 types.ServiceCreateOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ServiceCreate", []interface{}{arg1, arg2, arg3})
	fake.serviceCreateMutex.Unlock()
	if fake.ServiceCreateStub != nil {
		return fake.ServiceCreateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.serviceCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ServiceCreateCallCount() int {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	return len(fake.serviceCreateArgsForCall)
}

func (fake *fakeDockerClient) ServiceCreateCalls(stub func(context.Context, swarm.ServiceSpec, types.ServiceCreateOptions) (types.ServiceCreateResponse, error)) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = stub
}

func (fake *fakeDockerClient) ServiceCreateArgsForCall(i int) (context.Context, swarm.ServiceSpec, types.ServiceCreateOptions) {
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	argsForCall := fake.serviceCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ServiceCreateReturns(result1 types.ServiceCreateResponse, result2 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	fake.serviceCreateReturns = struct {
		result1 types.ServiceCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceCreateReturnsOnCall(i int, result1 types.ServiceCreateResponse, result2 error) {
	fake.serviceCreateMutex.Lock()
	defer fake.serviceCreateMutex.Unlock()
	fake.ServiceCreateStub = nil
	if fake.serviceCreateReturnsOnCall == nil {
		fake.serviceCreateReturnsOnCall = make(map[int]struct {
			result1 types.ServiceCreateResponse
			result2 error
		})
	}
	fake.serviceCreateReturnsOnCall[i] = struct {
		result1 types.ServiceCreateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceInspectWithRaw(arg1 context.Context, arg2 string, arg3 types.ServiceInspectOptions) (swarm.Service, []byte, error) {
	fake.serviceInspectWithRawMutex.Lock()
	ret, specificReturn := fake.serviceInspectWithRawReturnsOnCall[len(fake.serviceInspectWithRawArgsForCall)]
	fake.serviceInspectWithRawArgsForCall = append(fake.serviceInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ServiceInspectOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ServiceInspectWithRaw", []interface{}{arg1, arg2, arg3})
	fake.serviceInspectWithRawMutex.Unlock()
	if fake.ServiceInspectWithRawStub != nil {
		return fake.ServiceInspectWithRawStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.serviceInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) ServiceInspectWithRawCallCount() int {
	fake.serviceInspectWithRawMutex.RLock()
	defer fake.serviceInspectWithRawMutex.RUnlock()
	return len(fake.serviceInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) ServiceInspectWithRawCalls(stub func(context.Context, string, types.ServiceInspectOptions) (swarm.Service, []byte, error)) {
	fake.serviceInspectWithRawMutex.Lock()
	defer fake.serviceInspectWithRawMutex.Unlock()
	fake.ServiceInspectWithRawStub = stub
}

func (fake *fakeDockerClient) ServiceInspectWithRawArgsForCall(i int) (context.Context, string, types.ServiceInspectOptions) {
	fake.serviceInspectWithRawMutex.RLock()
	defer fake.serviceInspectWithRawMutex.RUnlock()
	argsForCall := fake.serviceInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ServiceInspectWithRawReturns(result1 swarm.Service, result2 []byte, result3 error) {
	fake.serviceInspectWithRawMutex.Lock()
	defer fake.serviceInspectWithRawMutex.Unlock()
	fake.ServiceInspectWithRawStub = nil
	fake.serviceInspectWithRawReturns = struct {
		result1 swarm.Service
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ServiceInspectWithRawReturnsOnCall(i int, result1 swarm.Service, result2 []byte, result3 error) {
	fake.serviceInspectWithRawMutex.Lock()
	defer fake.serviceInspectWithRawMutex.Unlock()
	fake.ServiceInspectWithRawStub = nil
	if fake.serviceInspectWithRawReturnsOnCall == nil {
		fake.serviceInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarm.Service
			result2 []byte
			result3 error
		})
	}
	fake.serviceInspectWithRawReturnsOnCall[i] = struct {
		result1 swarm.Service
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) ServiceList(arg1 context.Context, arg2 types.ServiceListOptions) ([]swarm.Service, error) {
	fake.serviceListMutex.Lock()
	ret, specificReturn := fake.serviceListReturnsOnCall[len(fake.serviceListArgsForCall)]
	fake.serviceListArgsForCall = append(fake.serviceListArgsForCall, struct {
		arg1 context.Context
		arg2 types.ServiceListOptions
	}{arg1, arg2})
	fake.recordInvocation("ServiceList", []interface{}{arg1, arg2})
	fake.serviceListMutex.Unlock()
	if fake.ServiceListStub != nil {
		return fake.ServiceListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.serviceListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ServiceListCallCount() int {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	return len(fake.serviceListArgsForCall)
}

func (fake *fakeDockerClient) ServiceListCalls(stub func(context.Context, types.ServiceListOptions) ([]swarm.Service, error)) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = stub
}

func (fake *fakeDockerClient) ServiceListArgsForCall(i int) (context.Context, types.ServiceListOptions) {
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	argsForCall := fake.serviceListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ServiceListReturns(result1 []swarm.Service, result2 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	fake.serviceListReturns = struct {
		result1 []swarm.Service
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceListReturnsOnCall(i int, result1 []swarm.Service, result2 error) {
	fake.serviceListMutex.Lock()
	defer fake.serviceListMutex.Unlock()
	fake.ServiceListStub = nil
	if fake.serviceListReturnsOnCall == nil {
		fake.serviceListReturnsOnCall = make(map[int]struct {
			result1 []swarm.Service
			result2 error
		})
	}
	fake.serviceListReturnsOnCall[i] = struct {
		result1 []swarm.Service
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceLogs(arg1 context.Context, arg2 string, arg3 types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.serviceLogsMutex.Lock()
	ret, specificReturn := fake.serviceLogsReturnsOnCall[len(fake.serviceLogsArgsForCall)]
	fake.serviceLogsArgsForCall = append(fake.serviceLogsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("ServiceLogs", []interface{}{arg1, arg2, arg3})
	fake.serviceLogsMutex.Unlock()
	if fake.ServiceLogsStub != nil {
		return fake.ServiceLogsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.serviceLogsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ServiceLogsCallCount() int {
	fake.serviceLogsMutex.RLock()
	defer fake.serviceLogsMutex.RUnlock()
	return len(fake.serviceLogsArgsForCall)
}

func (fake *fakeDockerClient) ServiceLogsCalls(stub func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)) {
	fake.serviceLogsMutex.Lock()
	defer fake.serviceLogsMutex.Unlock()
	fake.ServiceLogsStub = stub
}

func (fake *fakeDockerClient) ServiceLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.serviceLogsMutex.RLock()
	defer fake.serviceLogsMutex.RUnlock()
	argsForCall := fake.serviceLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) ServiceLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.serviceLogsMutex.Lock()
	defer fake.serviceLogsMutex.Unlock()
	fake.ServiceLogsStub = nil
	fake.serviceLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.serviceLogsMutex.Lock()
	defer fake.serviceLogsMutex.Unlock()
	fake.ServiceLogsStub = nil
	if fake.serviceLogsReturnsOnCall == nil {
		fake.serviceLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.serviceLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceRemove(arg1 context.Context, arg2 string) error {
	fake.serviceRemoveMutex.Lock()
	ret, specificReturn := fake.serviceRemoveReturnsOnCall[len(fake.serviceRemoveArgsForCall)]
	fake.serviceRemoveArgsForCall = append(fake.serviceRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ServiceRemove", []interface{}{arg1, arg2})
	fake.serviceRemoveMutex.Unlock()
	if fake.ServiceRemoveStub != nil {
		return fake.ServiceRemoveStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.serviceRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) ServiceRemoveCallCount() int {
	fake.serviceRemoveMutex.RLock()
	defer fake.serviceRemoveMutex.RUnlock()
	return len(fake.serviceRemoveArgsForCall)
}

func (fake *fakeDockerClient) ServiceRemoveCalls(stub func(context.Context, string) error) {
	fake.serviceRemoveMutex.Lock()
	defer fake.serviceRemoveMutex.Unlock()
	fake.ServiceRemoveStub = stub
}

func (fake *fakeDockerClient) ServiceRemoveArgsForCall(i int) (context.Context, string) {
	fake.serviceRemoveMutex.RLock()
	defer fake.serviceRemoveMutex.RUnlock()
	argsForCall := fake.serviceRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) ServiceRemoveReturns(result1 error) {
	fake.serviceRemoveMutex.Lock()
	defer fake.serviceRemoveMutex.Unlock()
	fake.ServiceRemoveStub = nil
	fake.serviceRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ServiceRemoveReturnsOnCall(i int, result1 error) {
	fake.serviceRemoveMutex.Lock()
	defer fake.serviceRemoveMutex.Unlock()
	fake.ServiceRemoveStub = nil
	if fake.serviceRemoveReturnsOnCall == nil {
		fake.serviceRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serviceRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) ServiceUpdate(arg1 context.Context, arg2 string, arg3 swarm.Version, arg4 swarm.ServiceSpec, arg5 types.ServiceUpdateOptions) (types.ServiceUpdateResponse, error) {
	fake.serviceUpdateMutex.Lock()
	ret, specificReturn := fake.serviceUpdateReturnsOnCall[len(fake.serviceUpdateArgsForCall)]
	fake.serviceUpdateArgsForCall = append(fake.serviceUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 swarm.Version
		arg4 swarm.ServiceSpec
		arg5 types.ServiceUpdateOptions
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("ServiceUpdate", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.serviceUpdateMutex.Unlock()
	if fake.ServiceUpdateStub != nil {
		return fake.ServiceUpdateStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.serviceUpdateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) ServiceUpdateCallCount() int {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	return len(fake.serviceUpdateArgsForCall)
}

func (fake *fakeDockerClient) ServiceUpdateCalls(stub func(context.Context, string, swarm.Version, swarm.ServiceSpec, types.ServiceUpdateOptions) (types.ServiceUpdateResponse, error)) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = stub
}

func (fake *fakeDockerClient) ServiceUpdateArgsForCall(i int) (context.Context, string, swarm.Version, swarm.ServiceSpec, types.ServiceUpdateOptions) {
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	argsForCall := fake.serviceUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *fakeDockerClient) ServiceUpdateReturns(result1 types.ServiceUpdateResponse, result2 error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = nil
	fake.serviceUpdateReturns = struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) ServiceUpdateReturnsOnCall(i int, result1 types.ServiceUpdateResponse, result2 error) {
	fake.serviceUpdateMutex.Lock()
	defer fake.serviceUpdateMutex.Unlock()
	fake.ServiceUpdateStub = nil
	if fake.serviceUpdateReturnsOnCall == nil {
		fake.serviceUpdateReturnsOnCall = make(map[int]struct {
			result1 types.ServiceUpdateResponse
			result2 error
		})
	}
	fake.serviceUpdateReturnsOnCall[i] = struct {
		result1 types.ServiceUpdateResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmGetUnlockKey(arg1 context.Context) (types.SwarmUnlockKeyResponse, error) {
	fake.swarmGetUnlockKeyMutex.Lock()
	ret, specificReturn := fake.swarmGetUnlockKeyReturnsOnCall[len(fake.swarmGetUnlockKeyArgsForCall)]
	fake.swarmGetUnlockKeyArgsForCall = append(fake.swarmGetUnlockKeyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("SwarmGetUnlockKey", []interface{}{arg1})
	fake.swarmGetUnlockKeyMutex.Unlock()
	if fake.SwarmGetUnlockKeyStub != nil {
		return fake.SwarmGetUnlockKeyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.swarmGetUnlockKeyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyCallCount() int {
	fake.swarmGetUnlockKeyMutex.RLock()
	defer fake.swarmGetUnlockKeyMutex.RUnlock()
	return len(fake.swarmGetUnlockKeyArgsForCall)
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyCalls(stub func(context.Context) (types.SwarmUnlockKeyResponse, error)) {
	fake.swarmGetUnlockKeyMutex.Lock()
	defer fake.swarmGetUnlockKeyMutex.Unlock()
	fake.SwarmGetUnlockKeyStub = stub
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyArgsForCall(i int) context.Context {
	fake.swarmGetUnlockKeyMutex.RLock()
	defer fake.swarmGetUnlockKeyMutex.RUnlock()
	argsForCall := fake.swarmGetUnlockKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyReturns(result1 types.SwarmUnlockKeyResponse, result2 error) {
	fake.swarmGetUnlockKeyMutex.Lock()
	defer fake.swarmGetUnlockKeyMutex.Unlock()
	fake.SwarmGetUnlockKeyStub = nil
	fake.swarmGetUnlockKeyReturns = struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmGetUnlockKeyReturnsOnCall(i int, result1 types.SwarmUnlockKeyResponse, result2 error) {
	fake.swarmGetUnlockKeyMutex.Lock()
	defer fake.swarmGetUnlockKeyMutex.Unlock()
	fake.SwarmGetUnlockKeyStub = nil
	if fake.swarmGetUnlockKeyReturnsOnCall == nil {
		fake.swarmGetUnlockKeyReturnsOnCall = make(map[int]struct {
			result1 types.SwarmUnlockKeyResponse
			result2 error
		})
	}
	fake.swarmGetUnlockKeyReturnsOnCall[i] = struct {
		result1 types.SwarmUnlockKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInit(arg1 context.Context, arg2 swarm.InitRequest) (string, error) {
	fake.swarmInitMutex.Lock()
	ret, specificReturn := fake.swarmInitReturnsOnCall[len(fake.swarmInitArgsForCall)]
	fake.swarmInitArgsForCall = append(fake.swarmInitArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.InitRequest
	}{arg1, arg2})
	fake.recordInvocation("SwarmInit", []interface{}{arg1, arg2})
	fake.swarmInitMutex.Unlock()
	if fake.SwarmInitStub != nil {
		return fake.SwarmInitStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.swarmInitReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) SwarmInitCallCount() int {
	fake.swarmInitMutex.RLock()
	defer fake.swarmInitMutex.RUnlock()
	return len(fake.swarmInitArgsForCall)
}

func (fake *fakeDockerClient) SwarmInitCalls(stub func(context.Context, swarm.InitRequest) (string, error)) {
	fake.swarmInitMutex.Lock()
	defer fake.swarmInitMutex.Unlock()
	fake.SwarmInitStub = stub
}

func (fake *fakeDockerClient) SwarmInitArgsForCall(i int) (context.Context, swarm.InitRequest) {
	fake.swarmInitMutex.RLock()
	defer fake.swarmInitMutex.RUnlock()
	argsForCall := fake.swarmInitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SwarmInitReturns(result1 string, result2 error) {
	fake.swarmInitMutex.Lock()
	defer fake.swarmInitMutex.Unlock()
	fake.SwarmInitStub = nil
	fake.swarmInitReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInitReturnsOnCall(i int, result1 string, result2 error) {
	fake.swarmInitMutex.Lock()
	defer fake.swarmInitMutex.Unlock()
	fake.SwarmInitStub = nil
	if fake.swarmInitReturnsOnCall == nil {
		fake.swarmInitReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.swarmInitReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInspect(arg1 context.Context) (swarm.Swarm, error) {
	fake.swarmInspectMutex.Lock()
	ret, specificReturn := fake.swarmInspectReturnsOnCall[len(fake.swarmInspectArgsForCall)]
	fake.swarmInspectArgsForCall = append(fake.swarmInspectArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("SwarmInspect", []interface{}{arg1})
	fake.swarmInspectMutex.Unlock()
	if fake.SwarmInspectStub != nil {
		return fake.SwarmInspectStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.swarmInspectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) SwarmInspectCallCount() int {
	fake.swarmInspectMutex.RLock()
	defer fake.swarmInspectMutex.RUnlock()
	return len(fake.swarmInspectArgsForCall)
}

func (fake *fakeDockerClient) SwarmInspectCalls(stub func(context.Context) (swarm.Swarm, error)) {
	fake.swarmInspectMutex.Lock()
	defer fake.swarmInspectMutex.Unlock()
	fake.SwarmInspectStub = stub
}

func (fake *fakeDockerClient) SwarmInspectArgsForCall(i int) context.Context {
	fake.swarmInspectMutex.RLock()
	defer fake.swarmInspectMutex.RUnlock()
	argsForCall := fake.swarmInspectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *fakeDockerClient) SwarmInspectReturns(result1 swarm.Swarm, result2 error) {
	fake.swarmInspectMutex.Lock()
	defer fake.swarmInspectMutex.Unlock()
	fake.SwarmInspectStub = nil
	fake.swarmInspectReturns = struct {
		result1 swarm.Swarm
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmInspectReturnsOnCall(i int, result1 swarm.Swarm, result2 error) {
	fake.swarmInspectMutex.Lock()
	defer fake.swarmInspectMutex.Unlock()
	fake.SwarmInspectStub = nil
	if fake.swarmInspectReturnsOnCall == nil {
		fake.swarmInspectReturnsOnCall = make(map[int]struct {
			result1 swarm.Swarm
			result2 error
		})
	}
	fake.swarmInspectReturnsOnCall[i] = struct {
		result1 swarm.Swarm
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) SwarmJoin(arg1 context.Context, arg2 swarm.JoinRequest) error {
	fake.swarmJoinMutex.Lock()
	ret, specificReturn := fake.swarmJoinReturnsOnCall[len(fake.swarmJoinArgsForCall)]
	fake.swarmJoinArgsForCall = append(fake.swarmJoinArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.JoinRequest
	}{arg1, arg2})
	fake.recordInvocation("SwarmJoin", []interface{}{arg1, arg2})
	fake.swarmJoinMutex.Unlock()
	if fake.SwarmJoinStub != nil {
		return fake.SwarmJoinStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.swarmJoinReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) SwarmJoinCallCount() int {
	fake.swarmJoinMutex.RLock()
	defer fake.swarmJoinMutex.RUnlock()
	return len(fake.swarmJoinArgsForCall)
}

func (fake *fakeDockerClient) SwarmJoinCalls(stub func(context.Context, swarm.JoinRequest) error) {
	fake.swarmJoinMutex.Lock()
	defer fake.swarmJoinMutex.Unlock()
	fake.SwarmJoinStub = stub
}

func (fake *fakeDockerClient) SwarmJoinArgsForCall(i int) (context.Context, swarm.JoinRequest) {
	fake.swarmJoinMutex.RLock()
	defer fake.swarmJoinMutex.RUnlock()
	argsForCall := fake.swarmJoinArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SwarmJoinReturns(result1 error) {
	fake.swarmJoinMutex.Lock()
	defer fake.swarmJoinMutex.Unlock()
	fake.SwarmJoinStub = nil
	fake.swarmJoinReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmJoinReturnsOnCall(i int, result1 error) {
	fake.swarmJoinMutex.Lock()
	defer fake.swarmJoinMutex.Unlock()
	fake.SwarmJoinStub = nil
	if fake.swarmJoinReturnsOnCall == nil {
		fake.swarmJoinReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmJoinReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmLeave(arg1 context.Context, arg2 bool) error {
	fake.swarmLeaveMutex.Lock()
	ret, specificReturn := fake.swarmLeaveReturnsOnCall[len(fake.swarmLeaveArgsForCall)]
	fake.swarmLeaveArgsForCall = append(fake.swarmLeaveArgsForCall, struct {
		arg1 context.Context
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("SwarmLeave", []interface{}{arg1, arg2})
	fake.swarmLeaveMutex.Unlock()
	if fake.SwarmLeaveStub != nil {
		return fake.SwarmLeaveStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.swarmLeaveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) SwarmLeaveCallCount() int {
	fake.swarmLeaveMutex.RLock()
	defer fake.swarmLeaveMutex.RUnlock()
	return len(fake.swarmLeaveArgsForCall)
}

func (fake *fakeDockerClient) SwarmLeaveCalls(stub func(context.Context, bool) error) {
	fake.swarmLeaveMutex.Lock()
	defer fake.swarmLeaveMutex.Unlock()
	fake.SwarmLeaveStub = stub
}

func (fake *fakeDockerClient) SwarmLeaveArgsForCall(i int) (context.Context, bool) {
	fake.swarmLeaveMutex.RLock()
	defer fake.swarmLeaveMutex.RUnlock()
	argsForCall := fake.swarmLeaveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SwarmLeaveReturns(result1 error) {
	fake.swarmLeaveMutex.Lock()
	defer fake.swarmLeaveMutex.Unlock()
	fake.SwarmLeaveStub = nil
	fake.swarmLeaveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmLeaveReturnsOnCall(i int, result1 error) {
	fake.swarmLeaveMutex.Lock()
	defer fake.swarmLeaveMutex.Unlock()
	fake.SwarmLeaveStub = nil
	if fake.swarmLeaveReturnsOnCall == nil {
		fake.swarmLeaveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmLeaveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmUnlock(arg1 context.Context, arg2 swarm.UnlockRequest) error {
	fake.swarmUnlockMutex.Lock()
	ret, specificReturn := fake.swarmUnlockReturnsOnCall[len(fake.swarmUnlockArgsForCall)]
	fake.swarmUnlockArgsForCall = append(fake.swarmUnlockArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.UnlockRequest
	}{arg1, arg2})
	fake.recordInvocation("SwarmUnlock", []interface{}{arg1, arg2})
	fake.swarmUnlockMutex.Unlock()
	if fake.SwarmUnlockStub != nil {
		return fake.SwarmUnlockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.swarmUnlockReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) SwarmUnlockCallCount() int {
	fake.swarmUnlockMutex.RLock()
	defer fake.swarmUnlockMutex.RUnlock()
	return len(fake.swarmUnlockArgsForCall)
}

func (fake *fakeDockerClient) SwarmUnlockCalls(stub func(context.Context, swarm.UnlockRequest) error) {
	fake.swarmUnlockMutex.Lock()
	defer fake.swarmUnlockMutex.Unlock()
	fake.SwarmUnlockStub = stub
}

func (fake *fakeDockerClient) SwarmUnlockArgsForCall(i int) (context.Context, swarm.UnlockRequest) {
	fake.swarmUnlockMutex.RLock()
	defer fake.swarmUnlockMutex.RUnlock()
	argsForCall := fake.swarmUnlockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) SwarmUnlockReturns(result1 error) {
	fake.swarmUnlockMutex.Lock()
	defer fake.swarmUnlockMutex.Unlock()
	fake.SwarmUnlockStub = nil
	fake.swarmUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmUnlockReturnsOnCall(i int, result1 error) {
	fake.swarmUnlockMutex.Lock()
	defer fake.swarmUnlockMutex.Unlock()
	fake.SwarmUnlockStub = nil
	if fake.swarmUnlockReturnsOnCall == nil {
		fake.swarmUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmUpdate(arg1 context.Context, arg2 swarm.Version, arg3 swarm.Spec, arg4 swarm.UpdateFlags) error {
	fake.swarmUpdateMutex.Lock()
	ret, specificReturn := fake.swarmUpdateReturnsOnCall[len(fake.swarmUpdateArgsForCall)]
	fake.swarmUpdateArgsForCall = append(fake.swarmUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 swarm.Version
		arg3 swarm.Spec
		arg4 swarm.UpdateFlags
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SwarmUpdate", []interface{}{arg1, arg2, arg3, arg4})
	fake.swarmUpdateMutex.Unlock()
	if fake.SwarmUpdateStub != nil {
		return fake.SwarmUpdateStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.swarmUpdateReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) SwarmUpdateCallCount() int {
	fake.swarmUpdateMutex.RLock()
	defer fake.swarmUpdateMutex.RUnlock()
	return len(fake.swarmUpdateArgsForCall)
}

func (fake *fakeDockerClient) SwarmUpdateCalls(stub func(context.Context, swarm.Version, swarm.Spec, swarm.UpdateFlags) error) {
	fake.swarmUpdateMutex.Lock()
	defer fake.swarmUpdateMutex.Unlock()
	fake.SwarmUpdateStub = stub
}

func (fake *fakeDockerClient) SwarmUpdateArgsForCall(i int) (context.Context, swarm.Version, swarm.Spec, swarm.UpdateFlags) {
	fake.swarmUpdateMutex.RLock()
	defer fake.swarmUpdateMutex.RUnlock()
	argsForCall := fake.swarmUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *fakeDockerClient) SwarmUpdateReturns(result1 error) {
	fake.swarmUpdateMutex.Lock()
	defer fake.swarmUpdateMutex.Unlock()
	fake.SwarmUpdateStub = nil
	fake.swarmUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) SwarmUpdateReturnsOnCall(i int, result1 error) {
	fake.swarmUpdateMutex.Lock()
	defer fake.swarmUpdateMutex.Unlock()
	fake.SwarmUpdateStub = nil
	if fake.swarmUpdateReturnsOnCall == nil {
		fake.swarmUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.swarmUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) TaskInspectWithRaw(arg1 context.Context, arg2 string) (swarm.Task, []byte, error) {
	fake.taskInspectWithRawMutex.Lock()
	ret, specificReturn := fake.taskInspectWithRawReturnsOnCall[len(fake.taskInspectWithRawArgsForCall)]
	fake.taskInspectWithRawArgsForCall = append(fake.taskInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("TaskInspectWithRaw", []interface{}{arg1, arg2})
	fake.taskInspectWithRawMutex.Unlock()
	if fake.TaskInspectWithRawStub != nil {
		return fake.TaskInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.taskInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) TaskInspectWithRawCallCount() int {
	fake.taskInspectWithRawMutex.RLock()
	defer fake.taskInspectWithRawMutex.RUnlock()
	return len(fake.taskInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) TaskInspectWithRawCalls(stub func(context.Context, string) (swarm.Task, []byte, error)) {
	fake.taskInspectWithRawMutex.Lock()
	defer fake.taskInspectWithRawMutex.Unlock()
	fake.TaskInspectWithRawStub = stub
}

func (fake *fakeDockerClient) TaskInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.taskInspectWithRawMutex.RLock()
	defer fake.taskInspectWithRawMutex.RUnlock()
	argsForCall := fake.taskInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) TaskInspectWithRawReturns(result1 swarm.Task, result2 []byte, result3 error) {
	fake.taskInspectWithRawMutex.Lock()
	defer fake.taskInspectWithRawMutex.Unlock()
	fake.TaskInspectWithRawStub = nil
	fake.taskInspectWithRawReturns = struct {
		result1 swarm.Task
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) TaskInspectWithRawReturnsOnCall(i int, result1 swarm.Task, result2 []byte, result3 error) {
	fake.taskInspectWithRawMutex.Lock()
	defer fake.taskInspectWithRawMutex.Unlock()
	fake.TaskInspectWithRawStub = nil
	if fake.taskInspectWithRawReturnsOnCall == nil {
		fake.taskInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 swarm.Task
			result2 []byte
			result3 error
		})
	}
	fake.taskInspectWithRawReturnsOnCall[i] = struct {
		result1 swarm.Task
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) TaskList(arg1 context.Context, arg2 types.TaskListOptions) ([]swarm.Task, error) {
	fake.taskListMutex.Lock()
	ret, specificReturn := fake.taskListReturnsOnCall[len(fake.taskListArgsForCall)]
	fake.taskListArgsForCall = append(fake.taskListArgsForCall, struct {
		arg1 context.Context
		arg2 types.TaskListOptions
	}{arg1, arg2})
	fake.recordInvocation("TaskList", []interface{}{arg1, arg2})
	fake.taskListMutex.Unlock()
	if fake.TaskListStub != nil {
		return fake.TaskListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.taskListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) TaskListCallCount() int {
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	return len(fake.taskListArgsForCall)
}

func (fake *fakeDockerClient) TaskListCalls(stub func(context.Context, types.TaskListOptions) ([]swarm.Task, error)) {
	fake.taskListMutex.Lock()
	defer fake.taskListMutex.Unlock()
	fake.TaskListStub = stub
}

func (fake *fakeDockerClient) TaskListArgsForCall(i int) (context.Context, types.TaskListOptions) {
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	argsForCall := fake.taskListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) TaskListReturns(result1 []swarm.Task, result2 error) {
	fake.taskListMutex.Lock()
	defer fake.taskListMutex.Unlock()
	fake.TaskListStub = nil
	fake.taskListReturns = struct {
		result1 []swarm.Task
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskListReturnsOnCall(i int, result1 []swarm.Task, result2 error) {
	fake.taskListMutex.Lock()
	defer fake.taskListMutex.Unlock()
	fake.TaskListStub = nil
	if fake.taskListReturnsOnCall == nil {
		fake.taskListReturnsOnCall = make(map[int]struct {
			result1 []swarm.Task
			result2 error
		})
	}
	fake.taskListReturnsOnCall[i] = struct {
		result1 []swarm.Task
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskLogs(arg1 context.Context, arg2 string, arg3 types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.taskLogsMutex.Lock()
	ret, specificReturn := fake.taskLogsReturnsOnCall[len(fake.taskLogsArgsForCall)]
	fake.taskLogsArgsForCall = append(fake.taskLogsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.ContainerLogsOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("TaskLogs", []interface{}{arg1, arg2, arg3})
	fake.taskLogsMutex.Unlock()
	if fake.TaskLogsStub != nil {
		return fake.TaskLogsStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.taskLogsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) TaskLogsCallCount() int {
	fake.taskLogsMutex.RLock()
	defer fake.taskLogsMutex.RUnlock()
	return len(fake.taskLogsArgsForCall)
}

func (fake *fakeDockerClient) TaskLogsCalls(stub func(context.Context, string, types.ContainerLogsOptions) (io.ReadCloser, error)) {
	fake.taskLogsMutex.Lock()
	defer fake.taskLogsMutex.Unlock()
	fake.TaskLogsStub = stub
}

func (fake *fakeDockerClient) TaskLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.taskLogsMutex.RLock()
	defer fake.taskLogsMutex.RUnlock()
	argsForCall := fake.taskLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) TaskLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.taskLogsMutex.Lock()
	defer fake.taskLogsMutex.Unlock()
	fake.TaskLogsStub = nil
	fake.taskLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) TaskLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.taskLogsMutex.Lock()
	defer fake.taskLogsMutex.Unlock()
	fake.TaskLogsStub = nil
	if fake.taskLogsReturnsOnCall == nil {
		fake.taskLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.taskLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeCreate(arg1 context.Context, arg2 volume.VolumeCreateBody) (types.Volume, error) {
	fake.volumeCreateMutex.Lock()
	ret, specificReturn := fake.volumeCreateReturnsOnCall[len(fake.volumeCreateArgsForCall)]
	fake.volumeCreateArgsForCall = append(fake.volumeCreateArgsForCall, struct {
		arg1 context.Context
		arg2 volume.VolumeCreateBody
	}{arg1, arg2})
	fake.recordInvocation("VolumeCreate", []interface{}{arg1, arg2})
	fake.volumeCreateMutex.Unlock()
	if fake.VolumeCreateStub != nil {
		return fake.VolumeCreateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.volumeCreateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) VolumeCreateCallCount() int {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	return len(fake.volumeCreateArgsForCall)
}

func (fake *fakeDockerClient) VolumeCreateCalls(stub func(context.Context, volume.VolumeCreateBody) (types.Volume, error)) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = stub
}

func (fake *fakeDockerClient) VolumeCreateArgsForCall(i int) (context.Context, volume.VolumeCreateBody) {
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	argsForCall := fake.volumeCreateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) VolumeCreateReturns(result1 types.Volume, result2 error) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = nil
	fake.volumeCreateReturns = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeCreateReturnsOnCall(i int, result1 types.Volume, result2 error) {
	fake.volumeCreateMutex.Lock()
	defer fake.volumeCreateMutex.Unlock()
	fake.VolumeCreateStub = nil
	if fake.volumeCreateReturnsOnCall == nil {
		fake.volumeCreateReturnsOnCall = make(map[int]struct {
			result1 types.Volume
			result2 error
		})
	}
	fake.volumeCreateReturnsOnCall[i] = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeInspect(arg1 context.Context, arg2 string) (types.Volume, error) {
	fake.volumeInspectMutex.Lock()
	ret, specificReturn := fake.volumeInspectReturnsOnCall[len(fake.volumeInspectArgsForCall)]
	fake.volumeInspectArgsForCall = append(fake.volumeInspectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("VolumeInspect", []interface{}{arg1, arg2})
	fake.volumeInspectMutex.Unlock()
	if fake.VolumeInspectStub != nil {
		return fake.VolumeInspectStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.volumeInspectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) VolumeInspectCallCount() int {
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	return len(fake.volumeInspectArgsForCall)
}

func (fake *fakeDockerClient) VolumeInspectCalls(stub func(context.Context, string) (types.Volume, error)) {
	fake.volumeInspectMutex.Lock()
	defer fake.volumeInspectMutex.Unlock()
	fake.VolumeInspectStub = stub
}

func (fake *fakeDockerClient) VolumeInspectArgsForCall(i int) (context.Context, string) {
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	argsForCall := fake.volumeInspectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) VolumeInspectReturns(result1 types.Volume, result2 error) {
	fake.volumeInspectMutex.Lock()
	defer fake.volumeInspectMutex.Unlock()
	fake.VolumeInspectStub = nil
	fake.volumeInspectReturns = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeInspectReturnsOnCall(i int, result1 types.Volume, result2 error) {
	fake.volumeInspectMutex.Lock()
	defer fake.volumeInspectMutex.Unlock()
	fake.VolumeInspectStub = nil
	if fake.volumeInspectReturnsOnCall == nil {
		fake.volumeInspectReturnsOnCall = make(map[int]struct {
			result1 types.Volume
			result2 error
		})
	}
	fake.volumeInspectReturnsOnCall[i] = struct {
		result1 types.Volume
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeInspectWithRaw(arg1 context.Context, arg2 string) (types.Volume, []byte, error) {
	fake.volumeInspectWithRawMutex.Lock()
	ret, specificReturn := fake.volumeInspectWithRawReturnsOnCall[len(fake.volumeInspectWithRawArgsForCall)]
	fake.volumeInspectWithRawArgsForCall = append(fake.volumeInspectWithRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("VolumeInspectWithRaw", []interface{}{arg1, arg2})
	fake.volumeInspectWithRawMutex.Unlock()
	if fake.VolumeInspectWithRawStub != nil {
		return fake.VolumeInspectWithRawStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.volumeInspectWithRawReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *fakeDockerClient) VolumeInspectWithRawCallCount() int {
	fake.volumeInspectWithRawMutex.RLock()
	defer fake.volumeInspectWithRawMutex.RUnlock()
	return len(fake.volumeInspectWithRawArgsForCall)
}

func (fake *fakeDockerClient) VolumeInspectWithRawCalls(stub func(context.Context, string) (types.Volume, []byte, error)) {
	fake.volumeInspectWithRawMutex.Lock()
	defer fake.volumeInspectWithRawMutex.Unlock()
	fake.VolumeInspectWithRawStub = stub
}

func (fake *fakeDockerClient) VolumeInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.volumeInspectWithRawMutex.RLock()
	defer fake.volumeInspectWithRawMutex.RUnlock()
	argsForCall := fake.volumeInspectWithRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) VolumeInspectWithRawReturns(result1 types.Volume, result2 []byte, result3 error) {
	fake.volumeInspectWithRawMutex.Lock()
	defer fake.volumeInspectWithRawMutex.Unlock()
	fake.VolumeInspectWithRawStub = nil
	fake.volumeInspectWithRawReturns = struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) VolumeInspectWithRawReturnsOnCall(i int, result1 types.Volume, result2 []byte, result3 error) {
	fake.volumeInspectWithRawMutex.Lock()
	defer fake.volumeInspectWithRawMutex.Unlock()
	fake.VolumeInspectWithRawStub = nil
	if fake.volumeInspectWithRawReturnsOnCall == nil {
		fake.volumeInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.Volume
			result2 []byte
			result3 error
		})
	}
	fake.volumeInspectWithRawReturnsOnCall[i] = struct {
		result1 types.Volume
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *fakeDockerClient) VolumeList(arg1 context.Context, arg2 filters.Args) (volume.VolumeListOKBody, error) {
	fake.volumeListMutex.Lock()
	ret, specificReturn := fake.volumeListReturnsOnCall[len(fake.volumeListArgsForCall)]
	fake.volumeListArgsForCall = append(fake.volumeListArgsForCall, struct {
		arg1 context.Context
		arg2 filters.Args
	}{arg1, arg2})
	fake.recordInvocation("VolumeList", []interface{}{arg1, arg2})
	fake.volumeListMutex.Unlock()
	if fake.VolumeListStub != nil {
		return fake.VolumeListStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.volumeListReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) VolumeListCallCount() int {
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	return len(fake.volumeListArgsForCall)
}

func (fake *fakeDockerClient) VolumeListCalls(stub func(context.Context, filters.Args) (volume.VolumeListOKBody, error)) {
	fake.volumeListMutex.Lock()
	defer fake.volumeListMutex.Unlock()
	fake.VolumeListStub = stub
}

func (fake *fakeDockerClient) VolumeListArgsForCall(i int) (context.Context, filters.Args) {
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	argsForCall := fake.volumeListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) VolumeListReturns(result1 volume.VolumeListOKBody, result2 error) {
	fake.volumeListMutex.Lock()
	defer fake.volumeListMutex.Unlock()
	fake.VolumeListStub = nil
	fake.volumeListReturns = struct {
		result1 volume.VolumeListOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeListReturnsOnCall(i int, result1 volume.VolumeListOKBody, result2 error) {
	fake.volumeListMutex.Lock()
	defer fake.volumeListMutex.Unlock()
	fake.VolumeListStub = nil
	if fake.volumeListReturnsOnCall == nil {
		fake.volumeListReturnsOnCall = make(map[int]struct {
			result1 volume.VolumeListOKBody
			result2 error
		})
	}
	fake.volumeListReturnsOnCall[i] = struct {
		result1 volume.VolumeListOKBody
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumeRemove(arg1 context.Context, arg2 string, arg3 bool) error {
	fake.volumeRemoveMutex.Lock()
	ret, specificReturn := fake.volumeRemoveReturnsOnCall[len(fake.volumeRemoveArgsForCall)]
	fake.volumeRemoveArgsForCall = append(fake.volumeRemoveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("VolumeRemove", []interface{}{arg1, arg2, arg3})
	fake.volumeRemoveMutex.Unlock()
	if fake.VolumeRemoveStub != nil {
		return fake.VolumeRemoveStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.volumeRemoveReturns
	return fakeReturns.result1
}

func (fake *fakeDockerClient) VolumeRemoveCallCount() int {
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	return len(fake.volumeRemoveArgsForCall)
}

func (fake *fakeDockerClient) VolumeRemoveCalls(stub func(context.Context, string, bool) error) {
	fake.volumeRemoveMutex.Lock()
	defer fake.volumeRemoveMutex.Unlock()
	fake.VolumeRemoveStub = stub
}

func (fake *fakeDockerClient) VolumeRemoveArgsForCall(i int) (context.Context, string, bool) {
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	argsForCall := fake.volumeRemoveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *fakeDockerClient) VolumeRemoveReturns(result1 error) {
	fake.volumeRemoveMutex.Lock()
	defer fake.volumeRemoveMutex.Unlock()
	fake.VolumeRemoveStub = nil
	fake.volumeRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) VolumeRemoveReturnsOnCall(i int, result1 error) {
	fake.volumeRemoveMutex.Lock()
	defer fake.volumeRemoveMutex.Unlock()
	fake.VolumeRemoveStub = nil
	if fake.volumeRemoveReturnsOnCall == nil {
		fake.volumeRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.volumeRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *fakeDockerClient) VolumesPrune(arg1 context.Context, arg2 filters.Args) (types.VolumesPruneReport, error) {
	fake.volumesPruneMutex.Lock()
	ret, specificReturn := fake.volumesPruneReturnsOnCall[len(fake.volumesPruneArgsForCall)]
	fake.volumesPruneArgsForCall = append(fake.volumesPruneArgsForCall, struct {
		arg1 context.Context
		arg2 filters.Args
	}{arg1, arg2})
	fake.recordInvocation("VolumesPrune", []interface{}{arg1, arg2})
	fake.volumesPruneMutex.Unlock()
	if fake.VolumesPruneStub != nil {
		return fake.VolumesPruneStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.volumesPruneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *fakeDockerClient) VolumesPruneCallCount() int {
	fake.volumesPruneMutex.RLock()
	defer fake.volumesPruneMutex.RUnlock()
	return len(fake.volumesPruneArgsForCall)
}

func (fake *fakeDockerClient) VolumesPruneCalls(stub func(context.Context, filters.Args) (types.VolumesPruneReport, error)) {
	fake.volumesPruneMutex.Lock()
	defer fake.volumesPruneMutex.Unlock()
	fake.VolumesPruneStub = stub
}

func (fake *fakeDockerClient) VolumesPruneArgsForCall(i int) (context.Context, filters.Args) {
	fake.volumesPruneMutex.RLock()
	defer fake.volumesPruneMutex.RUnlock()
	argsForCall := fake.volumesPruneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *fakeDockerClient) VolumesPruneReturns(result1 types.VolumesPruneReport, result2 error) {
	fake.volumesPruneMutex.Lock()
	defer fake.volumesPruneMutex.Unlock()
	fake.VolumesPruneStub = nil
	fake.volumesPruneReturns = struct {
		result1 types.VolumesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) VolumesPruneReturnsOnCall(i int, result1 types.VolumesPruneReport, result2 error) {
	fake.volumesPruneMutex.Lock()
	defer fake.volumesPruneMutex.Unlock()
	fake.VolumesPruneStub = nil
	if fake.volumesPruneReturnsOnCall == nil {
		fake.volumesPruneReturnsOnCall = make(map[int]struct {
			result1 types.VolumesPruneReport
			result2 error
		})
	}
	fake.volumesPruneReturnsOnCall[i] = struct {
		result1 types.VolumesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *fakeDockerClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildCachePruneMutex.RLock()
	defer fake.buildCachePruneMutex.RUnlock()
	fake.buildCancelMutex.RLock()
	defer fake.buildCancelMutex.RUnlock()
	fake.clientVersionMutex.RLock()
	defer fake.clientVersionMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.configCreateMutex.RLock()
	defer fake.configCreateMutex.RUnlock()
	fake.configInspectWithRawMutex.RLock()
	defer fake.configInspectWithRawMutex.RUnlock()
	fake.configListMutex.RLock()
	defer fake.configListMutex.RUnlock()
	fake.configRemoveMutex.RLock()
	defer fake.configRemoveMutex.RUnlock()
	fake.configUpdateMutex.RLock()
	defer fake.configUpdateMutex.RUnlock()
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	fake.daemonHostMutex.RLock()
	defer fake.daemonHostMutex.RUnlock()
	fake.dialSessionMutex.RLock()
	defer fake.dialSessionMutex.RUnlock()
	fake.dialerMutex.RLock()
	defer fake.dialerMutex.RUnlock()
	fake.diskUsageMutex.RLock()
	defer fake.diskUsageMutex.RUnlock()
	fake.distributionInspectMutex.RLock()
	defer fake.distributionInspectMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.hTTPClientMutex.RLock()
	defer fake.hTTPClientMutex.RUnlock()
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.negotiateAPIVersionMutex.RLock()
	defer fake.negotiateAPIVersionMutex.RUnlock()
	fake.negotiateAPIVersionPingMutex.RLock()
	defer fake.negotiateAPIVersionPingMutex.RUnlock()
	fake.networkConnectMutex.RLock()
	defer fake.networkConnectMutex.RUnlock()
	fake.networkCreateMutex.RLock()
	defer fake.networkCreateMutex.RUnlock()
	fake.networkDisconnectMutex.RLock()
	defer fake.networkDisconnectMutex.RUnlock()
	fake.networkInspectMutex.RLock()
	defer fake.networkInspectMutex.RUnlock()
	fake.networkInspectWithRawMutex.RLock()
	defer fake.networkInspectWithRawMutex.RUnlock()
	fake.networkListMutex.RLock()
	defer fake.networkListMutex.RUnlock()
	fake.networkRemoveMutex.RLock()
	defer fake.networkRemoveMutex.RUnlock()
	fake.networksPruneMutex.RLock()
	defer fake.networksPruneMutex.RUnlock()
	fake.nodeInspectWithRawMutex.RLock()
	defer fake.nodeInspectWithRawMutex.RUnlock()
	fake.nodeListMutex.RLock()
	defer fake.nodeListMutex.RUnlock()
	fake.nodeRemoveMutex.RLock()
	defer fake.nodeRemoveMutex.RUnlock()
	fake.nodeUpdateMutex.RLock()
	defer fake.nodeUpdateMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.pluginCreateMutex.RLock()
	defer fake.pluginCreateMutex.RUnlock()
	fake.pluginDisableMutex.RLock()
	defer fake.pluginDisableMutex.RUnlock()
	fake.pluginEnableMutex.RLock()
	defer fake.pluginEnableMutex.RUnlock()
	fake.pluginInspectWithRawMutex.RLock()
	defer fake.pluginInspectWithRawMutex.RUnlock()
	fake.pluginInstallMutex.RLock()
	defer fake.pluginInstallMutex.RUnlock()
	fake.pluginListMutex.RLock()
	defer fake.pluginListMutex.RUnlock()
	fake.pluginPushMutex.RLock()
	defer fake.pluginPushMutex.RUnlock()
	fake.pluginRemoveMutex.RLock()
	defer fake.pluginRemoveMutex.RUnlock()
	fake.pluginSetMutex.RLock()
	defer fake.pluginSetMutex.RUnlock()
	fake.pluginUpgradeMutex.RLock()
	defer fake.pluginUpgradeMutex.RUnlock()
	fake.registryLoginMutex.RLock()
	defer fake.registryLoginMutex.RUnlock()
	fake.secretCreateMutex.RLock()
	defer fake.secretCreateMutex.RUnlock()
	fake.secretInspectWithRawMutex.RLock()
	defer fake.secretInspectWithRawMutex.RUnlock()
	fake.secretListMutex.RLock()
	defer fake.secretListMutex.RUnlock()
	fake.secretRemoveMutex.RLock()
	defer fake.secretRemoveMutex.RUnlock()
	fake.secretUpdateMutex.RLock()
	defer fake.secretUpdateMutex.RUnlock()
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	fake.serviceCreateMutex.RLock()
	defer fake.serviceCreateMutex.RUnlock()
	fake.serviceInspectWithRawMutex.RLock()
	defer fake.serviceInspectWithRawMutex.RUnlock()
	fake.serviceListMutex.RLock()
	defer fake.serviceListMutex.RUnlock()
	fake.serviceLogsMutex.RLock()
	defer fake.serviceLogsMutex.RUnlock()
	fake.serviceRemoveMutex.RLock()
	defer fake.serviceRemoveMutex.RUnlock()
	fake.serviceUpdateMutex.RLock()
	defer fake.serviceUpdateMutex.RUnlock()
	fake.swarmGetUnlockKeyMutex.RLock()
	defer fake.swarmGetUnlockKeyMutex.RUnlock()
	fake.swarmInitMutex.RLock()
	defer fake.swarmInitMutex.RUnlock()
	fake.swarmInspectMutex.RLock()
	defer fake.swarmInspectMutex.RUnlock()
	fake.swarmJoinMutex.RLock()
	defer fake.swarmJoinMutex.RUnlock()
	fake.swarmLeaveMutex.RLock()
	defer fake.swarmLeaveMutex.RUnlock()
	fake.swarmUnlockMutex.RLock()
	defer fake.swarmUnlockMutex.RUnlock()
	fake.swarmUpdateMutex.RLock()
	defer fake.swarmUpdateMutex.RUnlock()
	fake.taskInspectWithRawMutex.RLock()
	defer fake.taskInspectWithRawMutex.RUnlock()
	fake.taskListMutex.RLock()
	defer fake.taskListMutex.RUnlock()
	fake.taskLogsMutex.RLock()
	defer fake.taskLogsMutex.RUnlock()
	fake.volumeCreateMutex.RLock()
	defer fake.volumeCreateMutex.RUnlock()
	fake.volumeInspectMutex.RLock()
	defer fake.volumeInspectMutex.RUnlock()
	fake.volumeInspectWithRawMutex.RLock()
	defer fake.volumeInspectWithRawMutex.RUnlock()
	fake.volumeListMutex.RLock()
	defer fake.volumeListMutex.RUnlock()
	fake.volumeRemoveMutex.RLock()
	defer fake.volumeRemoveMutex.RUnlock()
	fake.volumesPruneMutex.RLock()
	defer fake.volumesPruneMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *fakeDockerClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.CommonAPIClient = new(fakeDockerClient)
